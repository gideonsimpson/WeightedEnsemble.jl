<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonequilibrium Sampling · WeightedEnsemble.jl</title><meta name="title" content="Nonequilibrium Sampling · WeightedEnsemble.jl"/><meta property="og:title" content="Nonequilibrium Sampling · WeightedEnsemble.jl"/><meta property="twitter:title" content="Nonequilibrium Sampling · WeightedEnsemble.jl"/><meta name="description" content="Documentation for WeightedEnsemble.jl."/><meta property="og:description" content="Documentation for WeightedEnsemble.jl."/><meta property="twitter:description" content="Documentation for WeightedEnsemble.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">WeightedEnsemble.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../struct1/">Structures</a></li><li><a class="tocitem" href="../../mutation/mutation1/">Mutation</a></li><li><span class="tocitem">Selection</span><ul><li><a class="tocitem" href="../../selection/selection1/">Selection Algorithms</a></li><li><a class="tocitem" href="../../selection/allocation1/">Allocation Algorithms</a></li><li><a class="tocitem" href="../../selection/resampling1/">Resampling Algorithms</a></li></ul></li><li><a class="tocitem" href="../../coarse1/">Coarse Modeling</a></li><li><a class="tocitem" href="../../util1/">Utility Functions</a></li><li><a class="tocitem" href="../../we1/">Weighted Ensemble Methods</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../equil1/">Equilibrium Sampling</a></li><li class="is-active"><a class="tocitem" href>Nonequilibrium Sampling</a><ul class="internal"><li><a class="tocitem" href="#The-Hill-Relation"><span>The Hill Relation</span></a></li><li><a class="tocitem" href="#Doublewell-Example"><span>Doublewell Example</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../refs1/">References</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Nonequilibrium Sampling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonequilibrium Sampling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gideonsimpson/WeightedEnsemble.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gideonsimpson/WeightedEnsemble.jl/blob/master/docs/src/examples/nonequil1.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Nonequilibrium-Sampling"><a class="docs-heading-anchor" href="#Nonequilibrium-Sampling">Nonequilibrium Sampling</a><a id="Nonequilibrium-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Nonequilibrium-Sampling" title="Permalink"></a></h1><p>These exmaples involve sampling from a nonequilbrium distribution.  They are particularly focused on computing the mean firest passage time (MFPT) via the Hill relation [<a href="../../refs1/#hill_free_1989">6</a>]; see, also, <a href="https://statisticalbiophysicsblog.org/?p=275">https://statisticalbiophysicsblog.org/?p=275</a>.  </p><h2 id="The-Hill-Relation"><a class="docs-heading-anchor" href="#The-Hill-Relation">The Hill Relation</a><a id="The-Hill-Relation-1"></a><a class="docs-heading-anchor-permalink" href="#The-Hill-Relation" title="Permalink"></a></h2><p>Consider the case of a discrete in time process, <span>$X_t$</span>, and two sets, <span>$A$</span> and <span>$B$</span>.  We wish to compute the mean first passage time for the process, starting in <span>$A$</span> to reach <span>$B$</span>.   One way of doing this would be sample initial conditions in <span>$A$</span> (this distribution, <span>$\mu_0$</span>, must be specified), and run them until they reach <span>$B$</span>.  But if  the MFPT is long, it will be computationally prohibitive to observe enough transitions to obtain a statistically meaningful estimate.</p><p>Now, we study an augmented processs, <span>$Y_t$</span>, where <span>$Y_t$</span> obeys the same dynamics as <span>$X_t$</span> until it reaches <span>$B$</span>, at which point it resets in <span>$A$</span>. Denote the steady state distribution of the <span>$Y_t$</span> process by <span>$\nu$</span>  The the Hill relation then says</p><p class="math-container">\[\frac{1}{\text{MFPT for $X_\cdot$}} = \mathbb{P}_\nu(B)\]</p><p>Consequently, large MFPT&#39;s correspond to low probability events; some form of importance sampling will be needed.  This is precisely the regime where WE can pay off.  We will simulate the augmented process and estimate <span>$\mathbb{P}_\nu(B)$</span> using the we with the observable <span>$1_B(y)$</span>.</p><p>To connect this to the continuous time case, frequently of interest, let us assume that <span>$X_t$</span> follows overdamped Langevin dynamics</p><p class="math-container">\[dX_t = -\nabla V(X_t)dt + \sqrt{2\beta^{-1}}dW_t,\]</p><p>The MFPT for this problem is computed first by solving the Poisson equation,</p><p class="math-container">\[L\tau_B = 0, \quad \tau_B|_{\partial B} = 0,\]</p><p>and then computing</p><p class="math-container">\[\text{MFPT $A\to B$} = \mathbb{E}_{\mu_0}[\tau_B(X)].\]</p><p>In the event that <span>$A=\{x_0\}$</span>, as it will be in the computational example, this is just <span>$\tau_B(x_0)$</span>.  As this Poisson problem will typically be in high dimension, solving it via classical methods is not feasable. </p><p>The associated <span>$Y_t$</span>, obeys this the overdamped Langevin equation until it hits <span>$\partial B$</span>, at which point it instantaneously retarts in <span>$A$</span> acoording ot the initial distribution <span>$\mu_0(dx) = \gamma_0(x)dx$</span>.  The modified process obeys the nonlocal Fokker-Planck equation:</p><p class="math-container">\[\partial_t \rho = L^\ast ρ + \gamma_0(x)\int_{\partial B}J_{\rho}\cdot n dS.\]</p><p>In the above expression, <span>$\int_{\partial B}J_{\rho}\cdot n dS$</span> is the integrated probability flux into the set <span>$B$</span>.  This has an associated noequilibrium steady state distribution (NESS).</p><p>To set this up to work with WE, we time discretize our process, <span>$\tilde{X}_{k}\approx X_{t_k}$</span> in some fashion and work with the associated augmented process (recylcing upon reaching <span>$B$</span>), <span>$\tilde{Y}_k$</span>.  The estimate of the MFPT of the original process is then</p><p class="math-container">\[\text{MFPT}\approx \frac{\Delta t}{\tilde{\nu}(B)}.\]</p><p>Indeed, this is approximate even without statistical error because we have lost information on the sub <span>$\Delta t$</span> time scale.  But this error will typically be small in comparison to the aforementioned statistical error. </p><h2 id="Doublewell-Example"><a class="docs-heading-anchor" href="#Doublewell-Example">Doublewell Example</a><a id="Doublewell-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Doublewell-Example" title="Permalink"></a></h2><ul><li><a href="#ODE-Results">ODE Results</a></li><li><a href="#Defining-the-Mutation-Step">Defining the Mutation Step</a></li><li><a href="#Defining-the-Bins">Defining the Bins</a></li><li><a href="#Run-WE-with-Uniform-Selection">Run WE with Uniform Selection</a></li><li><a href="#Comparison-with-Direct-Computation">Comparison with Direct Computation</a></li></ul><p>Following the <a href="../equil1/#double1">equilibrium example</a>, let us first compute, via ODE methods, the NESS along with the MFPT.  Here, we will take <span>$B = [b,\infty)$</span>, with <code>b=0.5</code> and <span>$\mu_0 =\delta_{x_0}$</span>, with <code>x0 = -1</code>.  Thus, we are estimating the MFPT for a trajecotry, starting in the left basin to ge into the &quot;heart&quot; of the right basin.  As we do not compute on an infinite domain, we impose a Neumann (reflecting) boundary condition at <span>$x=a&lt;x_0$</span> with <code>a=-2</code> in the example.  For low enough temperature, this is a good approximation.</p><h3 id="ODE-Results"><a class="docs-heading-anchor" href="#ODE-Results">ODE Results</a><a id="ODE-Results-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-Results" title="Permalink"></a></h3><p>For later comparison, we illustrate the results that are obtained usine ODE methods.  The NESS density can be obtained by integration:</p><pre><code class="language-julia hljs">using QuadGK
using TestLandscapes
using Plots

β = 10.0;
V_ode(x) = SymmetricDoubleWell(x);
x0 = -1.0;
a = -2;
b = 0.5;

C0 = quadgk(t -&gt; exp(β * V_ode(t)), x0, b)[1];
function f_(x)
    if (x &lt; x0)
        return C0 * exp(-β * V_ode(x))
    else
        return quadgk(t -&gt; exp(β * V_ode(t)), x, b)[1] * exp(-β * V_ode(x))
    end
end
Z = quadgk(f_, a, b)[1];
xx = LinRange(a, b, 200);
ρ = f_.(xx) / Z;

plot(xx, ρ, label=&quot;Density&quot;,lw=2)
xlabel!(&quot;x&quot;)
title!(&quot;NESS&quot;)</code></pre><img src="8b8af570.svg" alt="Example block output"/><p>For the MFPT, we use <code>BVPProblem</code> from <code>BoundaryValueDiffEq</code>:</p><pre><code class="language-julia hljs">using BoundaryValueDiffEq
using ForwardDiff

∇V_ode = x-&gt;ForwardDiff.derivative(V_ode, x);

function τ_rhs!(du, u, p, t)
    du[1] = u[2]
    du[2] = β * (∇V_ode(t) * u[2] - 1.0)
    du
end

function τ_bc!(res, u, p, t)
    res[1] = u[1][2];
    res[2] = u[end][1];
    res
end

tspan = (a, b)

τ_bvp = BVProblem(τ_rhs!, τ_bc!, [1., 0.], tspan)
τ_soln = solve(τ_bvp, MIRK4(), dt = 0.05);

MFPT = τ_soln(x0[1])[1];
@show MFPT;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">25473.945860592437</code></pre><h3 id="Defining-the-Mutation-Step"><a class="docs-heading-anchor" href="#Defining-the-Mutation-Step">Defining the Mutation Step</a><a id="Defining-the-Mutation-Step-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Mutation-Step" title="Permalink"></a></h3><p>In this example we use an Euler-Maruyama integrator with the recycling condition, with the <code>BasicMD</code> package:</p><pre><code class="language-julia hljs">using BasicMD
V(x) = SymmetricDoubleWell(x[1])
∇V! = (gradV, X) -&gt; ForwardDiff.gradient!(gradV, V, X);
Δt = 1e-2;  # time step
Δt_recycle = 1e-2
nΔt_recycle = Int(Δt_recycle / Δt); # number of time steps before applying recycler
nΔt_coarse = 1 * nΔt_recycle # number of time steps in a coarse step

sampler = EM(∇V!, β, Δt);

mutation_opts = MDOptions(n_iters=nΔt_coarse, n_save_iters=nΔt_coarse);

function restartA!(state::BasicMD.EMState)
    if (state.x[1] &gt; b)
        @. state.x = [x0]
        ∇V!(state.∇V, [x0])
    end
    state
end

constraints = Constraints(restartA!, trivial_constraint!, nΔt_recycle, nΔt_coarse);

mutation! = x -&gt; sample_trajectory!(x, sampler,constraints, options=mutation_opts); nothing</code></pre><h3 id="Defining-the-Bins"><a class="docs-heading-anchor" href="#Defining-the-Bins">Defining the Bins</a><a id="Defining-the-Bins-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Bins" title="Permalink"></a></h3><p>Bins will be defined via Voronoi cells:</p><pre><code class="language-julia hljs">using WeightedEnsemble
Δb = 0.2
x_voronoi = [[x - 0.5 * Δb] for x in -1.5:Δb:0.5+Δb]
@show n_bins = length(x_voronoi);
B0, bin_id, rebin! = setup_Voronoi_bins(x_voronoi); nothing</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">n_bins = length(x_voronoi) = 12</code></pre><h3 id="Run-WE-with-Uniform-Selection"><a class="docs-heading-anchor" href="#Run-WE-with-Uniform-Selection">Run WE with Uniform Selection</a><a id="Run-WE-with-Uniform-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Run-WE-with-Uniform-Selection" title="Permalink"></a></h3><p>As we will see, uniform selection will be sufficient to obtain relatively high quality results:</p><pre><code class="language-julia hljs">using Random

n_particles = 10^3;
E0 = Ensemble([[x_] for x_ in LinRange(-1.5, 0.5, n_particles)])
rebin!(E0, B0, 0);

uni_we_sampler = WEsampler(mutation!, uniform_selection!, rebin!);

n_we_steps = 10^3;

Random.seed!(100);
E_uni_trajectory, B_uni_trajectory = run_we(E0, B0, uni_we_sampler, n_we_steps); nothing</code></pre><p>First, we verify convergence to the target NESS distribution:</p><pre><code class="language-julia hljs">using Printf
hist_bins = LinRange(-2.0, 1.5, 41);

we_anim = @animate for (t, E) in enumerate(E_uni_trajectory)
    histogram([ξ_[1] for ξ_ in E.ξ], bins=hist_bins,
        weights=E.ω, norm=:pdf, alpha=0.5, label=&quot;Weighted Ensemble&quot;,
        yaxis=(:log10, [1e-6, 1e1]), legend=:topright)
    plot!(xx, ρ, lw=2, label=&quot;ODE&quot;)
    xlabel!(&quot;x&quot;)
    ylabel!(&quot;Density&quot;)
    xlims!(-1.5, 1)
    title!(@sprintf(&quot;t = %d&quot;, t))
end
gif(we_anim, fps =30)</code></pre><img src="493dfe54.gif" alt="Example block output"/><p>Next, we take a look at our quantity of interest, the estimate of <span>$\mathbb{P}_{\tilde{\nu}}(B)$</span>.  Using the Hill relation, this should correspond to an estimate of <span>$\Delta t/\text{MFPT}$</span>, the value we already computed by ODE methods:</p><pre><code class="language-julia hljs">using LinearAlgebra

f_uni_trajectory = zeros(n_we_steps);

fB = X -&gt; Float64(X[1] &gt; b); # define observable

for (j,E) in enumerate(E_uni_trajectory)
    f_uni_trajectory[j] = (E.ω ⋅ fB.(E.ξ));
end

plot(1:n_we_steps, f_uni_trajectory,  lw=2,yaxis=(:log10, [1e-8, :auto]),label=&quot;WE Est.&quot;)
plot!(1:n_we_steps, cumsum(f_uni_trajectory) ./(1:n_we_steps), label=&quot;WE Time Avg.&quot;)
plot!(1:n_we_steps, Δt / MFPT * ones(n_we_steps),
    lw=2,label=&quot;Δt/MFPT&quot;, color=:black, ls=:dash)
xlabel!(&quot;Iterate&quot;)</code></pre><img src="f34e65e1.svg" alt="Example block output"/><p>We have a good estimate after 500 iterations.</p><h3 id="Comparison-with-Direct-Computation"><a class="docs-heading-anchor" href="#Comparison-with-Direct-Computation">Comparison with Direct Computation</a><a id="Comparison-with-Direct-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-with-Direct-Computation" title="Permalink"></a></h3><p>As in the equilibrium case, an attempt to estimate the MFPT via the Hill relation, without using WE, will result in very poor results:</p><pre><code class="language-julia hljs">Random.seed!(200)
trivial_we_sampler = WEsampler(mutation!, (E, B, t)-&gt;trivial_selection!(E), rebin!);
f_direct_trajectory = run_we_observables(E0, B0, trivial_we_sampler, n_we_steps, (fB,))[:];

plot(1:n_we_steps, f_uni_trajectory,  lw=2,yaxis=(:log10, [1e-8, :auto]), label=&quot;WE Est.&quot;)
plot!(1:n_we_steps, cumsum(f_uni_trajectory) ./(1:n_we_steps), label=&quot;WE Time Avg.&quot;)
plot!(1:n_we_steps, f_direct_trajectory, label=&quot;Direct Est.&quot;)
plot!(1:n_we_steps, cumsum(f_direct_trajectory) ./(1:n_we_steps), label=&quot;Direct Time Avg.&quot;)
plot!(1:n_we_steps, Δt / MFPT * ones(n_we_steps),
    lw=2,label=&quot;Δt/MFPT&quot;, color=:black, ls=:dash)
xlabel!(&quot;Iterate&quot;)</code></pre><img src="dfb97723.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../equil1/">« Equilibrium Sampling</a><a class="docs-footer-nextpage" href="../../refs1/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Sunday 24 March 2024 04:40">Sunday 24 March 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
