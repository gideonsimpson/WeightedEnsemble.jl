<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · WeightedEnsemble.jl</title><meta name="title" content="Home · WeightedEnsemble.jl"/><meta property="og:title" content="Home · WeightedEnsemble.jl"/><meta property="twitter:title" content="Home · WeightedEnsemble.jl"/><meta name="description" content="Documentation for WeightedEnsemble.jl."/><meta property="og:description" content="Documentation for WeightedEnsemble.jl."/><meta property="twitter:description" content="Documentation for WeightedEnsemble.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>WeightedEnsemble.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Algorithm-Overview"><span>Algorithm Overview</span></a></li><li><a class="tocitem" href="#Caveats"><span>Caveats</span></a></li><li><a class="tocitem" href="#Collaborators"><span>Collaborators</span></a></li><li><a class="tocitem" href="#Acknowledgements"><span>Acknowledgements</span></a></li></ul></li><li><a class="tocitem" href="struct1/">Structures</a></li><li><a class="tocitem" href="mutation/mutation1/">Mutation</a></li><li><span class="tocitem">Selection</span><ul><li><a class="tocitem" href="selection/selection1/">Selection Algorithms</a></li><li><a class="tocitem" href="selection/allocation1/">Allocation Algorithms</a></li><li><a class="tocitem" href="selection/resampling1/">Resampling Algorithms</a></li></ul></li><li><a class="tocitem" href="coarse1/">Coarse Modeling</a></li><li><a class="tocitem" href="util1/">Utility Functions</a></li><li><a class="tocitem" href="we1/">Weighted Ensemble Methods</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/equil1/">Equilibrium Sampling</a></li></ul></li><li><a class="tocitem" href="refs1/">References</a></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gideonsimpson/WeightedEnsemble.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gideonsimpson/WeightedEnsemble.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="WeightedEnsemble.jl"><a class="docs-heading-anchor" href="#WeightedEnsemble.jl">WeightedEnsemble.jl</a><a id="WeightedEnsemble.jl-1"></a><a class="docs-heading-anchor-permalink" href="#WeightedEnsemble.jl" title="Permalink"></a></h1><ul><li><a href="#WeightedEnsemble.jl">WeightedEnsemble.jl</a></li><li class="no-marker"><ul><li><a href="#Algorithm-Overview">Algorithm Overview</a></li><li><a href="#Caveats">Caveats</a></li><li><a href="#Collaborators">Collaborators</a></li><li><a href="#Acknowledgements">Acknowledgements</a></li></ul></li></ul><h2 id="Algorithm-Overview"><a class="docs-heading-anchor" href="#Algorithm-Overview">Algorithm Overview</a><a id="Algorithm-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Overview" title="Permalink"></a></h2><ul><li><a href="#Selection">Selection</a></li><li><a href="#Bins">Bins</a></li><li><a href="#Mutation">Mutation</a></li><li><a href="#Unbiasedness">Unbiasedness</a></li><li><a href="#Estimation">Estimation</a></li><li><a href="#Implementation">Implementation</a></li></ul><p>Weighted Ensemble (WE) is a variance reduction strategy that can be used to, amongst other things, estimate rare events.  More generally, it is designed to estimate</p><p class="math-container">\[\mathbb{E}_{\mu}[f(X)] = \mu(f)\]</p><p>for some Quantity of Interest (QoI), <span>$f$</span>, with respect to some target measure, <span>$\mu$</span>.   One of the major advantages of WE  over other variance reduction strategies is that it makes rather minimal assumptions on the Markov underlying process.  Indeed, there is no assumption of reversibility of the process, nor is there any need to evaluate or otherwise estimate a likelihood.  It is sufficient to be able to simulate the associated process, i.e., sample a Markov kernel, <span>$K$</span>, for which <span>$\mu$</span> is the stationary distribution.  A key application of this approach is in the computation of mean first passage times (MFPTs) via the <a href="https://statisticalbiophysicsblog.org/?p=8">Hill relation</a>.</p><p>This implementation of WE makes use of a fixed number, <span>$N$</span>, particles, <span>$\xi^{i}$</span>, each carrying weight <span>$\omega^{i}$</span>.  At algorithmic time <span>$t$</span>, we denote</p><p class="math-container">\[\mu_t^{N}(dx) = \sum_{i=1}^N \omega_t^{i}\delta_{\xi_t^{i}}(dx)\]</p><p>The weights are assumed to be positive and sum to one.  The particle ensemble is stored in an <a href="struct1/#WeightedEnsemble.Ensemble"><code>Ensemble</code></a> data structure. The ensemble is evolved, successively, in two steps, <em>selection</em> and <em>mutation</em>.  As the partilces and weights evolve in time, we add a <span>$t$</span> subscript to indicate that these quantities change, <span>$\{(\omega_t^{i},\xi_t^{i}\}$</span>.</p><p>This implementation has been used in [<a href="refs1/#aristoff_weighted_2023">1</a>, <a href="refs1/#webber_splitting_2020">2</a>].  It is heavily influenced by the algoirthmic description found in [<a href="refs1/#aristoff_optimizing_2020">3</a>].  </p><h3 id="Selection"><a class="docs-heading-anchor" href="#Selection">Selection</a><a id="Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Selection" title="Permalink"></a></h3><p>During the selection step, particles are resampled from the empirical distribution in such a way so as to maintain unbiasedness <em>and</em> reduce variance with respect to some quantity of interest.  The ensemble after selection is represented by</p><p class="math-container">\[\hat{\mu}_t^{N}(dx) = \sum_{i=1}^N \hat{\omega}_t^{i}\delta_{\hat{\xi}_t^{i}}(dx)\]</p><p>See <a href="selection/selection1/#Selection-Algorithms">Selection Algorithms</a> and related documents for additional details on this step.</p><h3 id="Bins"><a class="docs-heading-anchor" href="#Bins">Bins</a><a id="Bins-1"></a><a class="docs-heading-anchor-permalink" href="#Bins" title="Permalink"></a></h3><p>To understand more of how the selection step works, it is essential to introduce the concept of bins.  Indeed, this implementation of WE is <em>bin based</em>, in the following sense.  The indices of the particles are partitioned into bins, <span>$u_1, u_2,\ldots, u_{M}$</span>, where <span>$M$</span> is the number of partitions.  Often, these bins are determined by a disjoint partition of the state space, <span>$\mathcal{X}$</span> as</p><p class="math-container">\[\mathcal{X} = \bigcup_{i=1}^M \mathcal{B}_i, \quad j \in u_i \leftrightarrow \xi_t^j\in \mathcal{B}_i\]</p><p>Though the presentation here assumes that the bins are statically (independent of <span>$t$</span>), these need not be the case in general.  Associated with each bin is the particle count at time <span>$t$</span>, <span>$n_t^i=|u_i|$</span>, and the bin weight, <span>$\nu_t^i$</span>, given by</p><p class="math-container">\[\nu^i_t = \sum_{j\in u_i}\omega^j.\]</p><p>The bins and their features are recorded in a <a href="struct1/#WeightedEnsemble.Bins"><code>Bins</code></a> data structure.</p><p>To perform the selection step, one first performs the allocation steps:</p><ul><li>First, we determine how many particles should reside in each of the bins, <span>$C_t(u)$</span>, after selection.  This is implemented to satisfy total particle conservation</li></ul><p class="math-container">\[\sum_{i=1}^{M}C_t(u_i) = N.\]</p><p>A simple, though suboptimal, choice is uniform allocation, in which <span>$C_t(u_i)\approx 1/M$</span>.</p><ul><li>Second, we determine how many offspring each particle should have.  This is implemented to constrain the bin count from the first step,</li></ul><p class="math-container">\[C_t(u_i)=\sum_{j\in u_i}C_t^j.\]</p><p>This is typically done using multinomial resampling, with</p><p class="math-container">\[(C_t^{j_k}) \sim \mathrm{Multi.}\left(C_t(u_i),\frac{\omega_t^{j_1}}{\nu_t^i},\frac{\omega_t^{j_2}}{\nu_t^i},\ldots \right)\]</p><p>where the <span>$j_k \in u_i$</span>.  </p><p>Having allocated the number of offspring to each particle, we then repopulate our ensemble as:</p><ul><li>Offspring of particle <span>$\xi_{t}^j$</span> are assigned this as their position;</li><li>Offspring of particles in bin <span>$u_i$</span> are all assigned weight <span>$\nu_t^i/C_t(u_i)$</span>.</li></ul><p>There are some additional subtlesties that are implemented to ensure the allocation and selection with bins behaves as expected.</p><h3 id="Mutation"><a class="docs-heading-anchor" href="#Mutation">Mutation</a><a id="Mutation-1"></a><a class="docs-heading-anchor-permalink" href="#Mutation" title="Permalink"></a></h3><p>During the mutation step, the particles evolve freely over one algorithmic time unit according to a user defined Markov kernel, <span>$K$</span>, with <span>$\xi_{t+1}^{i}\sim K(\hat{\xi}_t^{i}, dx)$</span>, and <span>$\omega_{t+1}^{i}= \hat{\omega}_t^{i}$</span>.  We then have the updated ensemble,</p><p class="math-container">\[\mu_{t+1}^{N}(dx) = \sum_{i=1}^N \omega_{t+1}^{i}\delta_{\xi_{t+1}^{i}}(dx)\]</p><p>See <a href="mutation/mutation1/#mutation1">Mutation</a> for additional information on implemenation.</p><h3 id="Unbiasedness"><a class="docs-heading-anchor" href="#Unbiasedness">Unbiasedness</a><a id="Unbiasedness-1"></a><a class="docs-heading-anchor-permalink" href="#Unbiasedness" title="Permalink"></a></h3><p>Repeating the above alternating selection/mutation steps, the key feature of WE is as follows. Denote by <span>$\mu$</span> the invariant measure associated with the Markov kernel <span>$K$</span> such that <span>$\mu K=\mu$</span>.  Additionally, suppose <span>$\omega_0^{i}=1/N$</span> and <span>$\xi_0^{i}\sim \mu_0$</span> be i.i.d.  Lastly, denote by <span>$\mu_t = \mu_0 K^t$</span>.  Then for any observable <span>$f$</span>,</p><p class="math-container">\[\mu_t(f)=\mathbb{E}_{\mu_0}[f(X_t)] = \mathbb{E}[\mu_t^{N}(f)]= \mathbb{E}[\hat{\mu}_t^{N}(f)],\]</p><p>where the latter two expectations are ensemble averages over the WE process.  Consequently, WE is <em>unbiased</em>, and it is providing <span>$N$</span>-particle approximations of the distribution, <span>$\mu_t$</span>.</p><h3 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h3><p>WE can thus be used to compute averages against the associated a target stationary measure, <span>$\mu$</span>, in the usual way:</p><p class="math-container">\[\mu(f) = \lim_{t\to\infty} \mu_t(f)= \lim_{t\to \infty}\frac{1}{t}\sum_{s=0}^{t-1} \mu_s(f) = \lim_{t\to \infty}\frac{1}{t}\sum_{s=0}^{t-1} \mu^{N}_s(f).\]</p><p>This is what we will use to make estimates; by taking <span>$t$</span> sufficiently large,</p><p class="math-container">\[\mu(f) \approx \frac{1}{t}\sum_{s=0}^{t-1} \mu^{N}_s(f)\]</p><p>A key thing to note is that WE does <strong>not</strong> accelerate mixing.  The mixing rate is controlled by the underlying Markov process.  What WE does do is, ideally, provide very low variance estimates of <span>$\mu_t(f)$</span>.  </p><p>WE can also be used to estimate finite time non-equilibrium quantities.</p><h3 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h3><p>To run WE, we must define a <a href="struct1/#WeightedEnsemble.WEsampler"><code>WEsampler</code></a> <code>sampler</code>, which defines the above steps.  Indeed, to recap, one must code up steps for</p><ul><li><code>selection!(E, B, t)</code> - This is an in place transform that modifies the ensemble, <code>E</code>, and the bins <code>B</code>.  It may be time dependent.</li><li><code>mutation!(ξ)</code> - This is an in place transform corresponds to the application of the Markov kernel to the state, <span>$\xi \sim K(\xi,\bullet)$</span>.  Though this operation is vectorized, it does defined on the underlying state space, not the ensemble or bin structures.  It is assumed to be time homogeneous.</li><li><code>sampler.rebin!(E, B, t+1)</code> - This is applied after mutation, at time <span>$t+1$</span>, and determines which particles are in which bins, updating the structures accordingly.  It also retabulates the weight, <span>$\nu_t^i$</span> of each bin.</li></ul><p>Having defined a sampler structure and provided initial <code>E0</code> ensemble and <code>B0</code> bins structures, WE is then executed with the command</p><pre><code class="nohighlight hljs">n_we_steps = 10; 
E_trajectory, B_trajectory = run_we(E0, B0, sampler, n_we_steps);</code></pre><p>The data structures contain, amongst other things,:</p><ul><li><code>E_trajctory</code> - <span>$\{(\omega_t^i, \xi_t^i\}$</span>, <span>$\{(\\hat{omega}_t^i, \hat{\xi}_t^i\}$</span>;</li><li><code>B_trajectory</code> - <span>$n_t^i$</span>, <span>$\nu_t^i$</span>.</li></ul><p>These can be used to compute the QoI.</p><h2 id="Caveats"><a class="docs-heading-anchor" href="#Caveats">Caveats</a><a id="Caveats-1"></a><a class="docs-heading-anchor-permalink" href="#Caveats" title="Permalink"></a></h2><p>There is some partial parallelization implemented, both with threads and with <code>Distributed</code>.  In both cases, the parallelization is only with respect to the application of the <code>mutation!</code> step, presumed to be the most costly piece of the algorithm.  It does not currently make use of distributed data structures or parallelize the selection step.</p><h2 id="Collaborators"><a class="docs-heading-anchor" href="#Collaborators">Collaborators</a><a id="Collaborators-1"></a><a class="docs-heading-anchor-permalink" href="#Collaborators" title="Permalink"></a></h2><ul><li>D. Aristoff</li><li>J. Copperman</li><li>L. F. Doherty</li><li>F. G. Jones</li><li>R. J. Webber</li><li>D. M. Zuckerman</li></ul><h2 id="Acknowledgements"><a class="docs-heading-anchor" href="#Acknowledgements">Acknowledgements</a><a id="Acknowledgements-1"></a><a class="docs-heading-anchor-permalink" href="#Acknowledgements" title="Permalink"></a></h2><p>This work was supported in part by the US National Science Foundation Grants DMS-1818716 and DMS-2111278.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="struct1/">Structures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Saturday 16 March 2024 18:18">Saturday 16 March 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
