var documenterSearchIndex = {"docs":
[{"location":"struct1/#Data-Structures-for-Weighted-Ensemble","page":"Structures","title":"Data Structures for Weighted Ensemble","text":"","category":"section"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Pages = [\"struct1.md\"]","category":"page"},{"location":"struct1/#Ensembles","page":"Structures","title":"Ensembles","text":"","category":"section"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Ensemble","category":"page"},{"location":"struct1/#WeightedEnsemble.Ensemble","page":"Structures","title":"WeightedEnsemble.Ensemble","text":"Ensemble{TP, TF<:AbstractFloat, TI<:Integer, TD}\n\nA particle ensemble structure designed for WE with bins.\n\nFields\n\nξ̂ - particle positions after selection, before mutation\nξ - particle positions after mutation\nω̂ - partice weights after selection, before mutation\nω - partice weights after mutation\nb̂ - particle bin after selection, before mutation\nb - particle bin after mutation\no - number of offspring of the particle\nd̂ - auxiliary data for each particle after selection, before mutation\nd - auxiliary data for each particle, after mutation\n\n\n\n\n\n","category":"type"},{"location":"struct1/","page":"Structures","title":"Structures","text":"The ensemble data structure holds the information about (omega_t^(i) xi_t^(i), along with the post selection step (hatomega_t^(i) hatxi_t^(i).  Fo convenience, it also carries information about the bin the particle currently resides in.  The structures d and d̂ are optional for carrying any auxiliary information.","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"A convenience constructor has been included in the case that mu_0=delta_x_0:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Dirac_to_Ensemble","category":"page"},{"location":"struct1/#WeightedEnsemble.Dirac_to_Ensemble","page":"Structures","title":"WeightedEnsemble.Dirac_to_Ensemble","text":"Dirac_to_Ensemble(X, n_particles; d = Nothing())\n\nConvenience function for construction an ensemble from a single initial walker.  This hard codes the weights to be Float64.\n\nArguments\n\nX - Starting state of all walkers\n\n*n_particles - Number of walkers in the ensemble\n\nOptional Arguments\n\nd = Nothing()) - optional auxliary data\n\n\n\n\n\n","category":"function"},{"location":"struct1/","page":"Structures","title":"Structures","text":"As an example, if our problem is posed in mathbbR, an initial ensemble could be constructed:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"x0 = [-1.0];\nn_particles = 100;\nE0 = Dirac_to_Ensemble(x0, n_particles);","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"This initializes the bin id field, b, to zeros.  It will be neccessary to either manually assign this field, or to call the user defined rebin! function:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"rebin!(E0, B0, 0);","category":"page"},{"location":"struct1/#Bins","page":"Structures","title":"Bins","text":"","category":"section"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Bins","category":"page"},{"location":"struct1/#WeightedEnsemble.Bins","page":"Structures","title":"WeightedEnsemble.Bins","text":"Bins{TS, TW, TBI, TT}\n\nA bin structure designed for WE\n\nFields\n\nΩ - structure containing information for uniquely identifying each bin\nn - number of particles in each bin\ntarget - target number of particles in each bin\nν - weight of each bin\nd - auxiliary bin data\n\n\n\n\n\n","category":"type"},{"location":"struct1/","page":"Structures","title":"Structures","text":"In addition to defining the Bins data strucutre, it will also be essential to provide:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"bin_id(x) - This maps points in the state space to an integer indexing fo the bins.\nrebin!(E, B, t) - This determines the bin of each particle, records this in the ensemble E.b field, sums the weights of all particles within the bins, and updates this in the bins B.ν field.  This may be time dependent.","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Several tools have been provided to simplify the construction of the bins.  ","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"WeightedEnsemble.Points_to_Bins","category":"page"},{"location":"struct1/#WeightedEnsemble.Points_to_Bins","page":"Structures","title":"WeightedEnsemble.Points_to_Bins","text":"Points_to_Bins(points; d = Nothing())\n\nConvenience function for constructing a bin structure identified by a sequence of points.\n\nArguments\n\npoints - An array of points that can be used to define Voronoi cells\n\nOptional Arguments\n\nd = Nothing()) - optional auxliary data ``\n\n\n\n\n\n","category":"function"},{"location":"struct1/","page":"Structures","title":"Structures","text":"This is useful if the bins can be sensibily identified with a set of points in the state space, as in the case of a Voronoi tesselation.  Indeed, as Voronoi tesselations are often used, we have","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"setup_Voronoi_bins","category":"page"},{"location":"struct1/#WeightedEnsemble.setup_Voronoi_bins","page":"Structures","title":"WeightedEnsemble.setup_Voronoi_bins","text":"setup_Voronoi_bins(voronoi_pts; d = Nothing())\n\nConvenience function for constructing bins, a bin id function, and a rebinning function based on a set of Voronoi points\n\nArguments\n\nvoronoi_pts - User specified Voronoi cell centers\n\nOptional Arguments\n\nd = Nothing()) - optional auxliary data \n\n\n\n\n\n","category":"function"},{"location":"struct1/","page":"Structures","title":"Structures","text":"As an example, suppose our Voronoi bins are points in mathbbR^2, then the following code will produce all the needed functions:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"voronoi_centers = [[-1.0, -2.0], [2.0, 1.0], [1.0, 0.]];\nB0, bin_id, rebin! = setup_Voronoi_bins(voronoi_centers);","category":"page"},{"location":"struct1/#Samplers","page":"Structures","title":"Samplers","text":"","category":"section"},{"location":"struct1/","page":"Structures","title":"Structures","text":"WEsampler","category":"page"},{"location":"struct1/#WeightedEnsemble.WEsampler","page":"Structures","title":"WeightedEnsemble.WEsampler","text":"WEsampler(mutation!, selection!, rebin!; analysis! = trivial_analysis!)\n\nArguments\n\nmutation! - mutation step\nselection! - selection step\nrebin! - rebinning step\n\nOptional Arguments\n\nanalysis! = trivial_analysis! - analysis step\n\n\n\n\n\n","category":"type"},{"location":"we1/#Weighted-Ensemble-Methods","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"","category":"section"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"Pages = [\"we1.md\"]","category":"page"},{"location":"we1/#Serial-Methods","page":"Weighted Ensemble Methods","title":"Serial Methods","text":"","category":"section"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"run_we\nrun_we_observables\nrun_we!","category":"page"},{"location":"we1/#WeightedEnsemble.run_we","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.run_we","text":"run_we(E₀, B₀, sampler, n_we_steps; n_save_iters = 1)\n\nRun a serial WE simulation, optionally returning the ensemble at each, step with\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\nOptional Arguments\n\nn_save_iters = 1 - save the ensemble and bins every n_save_iters iterations.  Set n_save_iters=n_we_steps to only save the final values.\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.run_we_observables","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.run_we_observables","text":"run_we_observables(E₀, B₀, sampler, n_we_steps, observables)\n\nRun a serial WE simulation, returning the values a specified fucntion, f, along the trajecotry.\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\nobservables - Tuple of scalar observable functions for the ergodic average\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.run_we!","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.run_we!","text":"run_we!(E, B, sampler, n_we_steps)\n\nRun an in place serial WE simulation with\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\n\n\n\n\n","category":"function"},{"location":"we1/#Multithreated-Methods","page":"Weighted Ensemble Methods","title":"Multithreated Methods","text":"","category":"section"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"These methods make use of multithreading in the mutation step.","category":"page"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"trun_we\ntrun_we_observables\ntrun_we!","category":"page"},{"location":"we1/#WeightedEnsemble.trun_we","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.trun_we","text":"trun_we(E₀, B₀, sampler, n_we_steps; n_save_iters = 1)\n\nRun a multithreaded WE simulation, optionally returning the ensemble at each, step with\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\nOptional Arguments\n\nn_save_iters = 1 - save the ensemble and bins every n_save_iters iterations.  Set n_save_iters=n_we_steps to only save the final values.\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.trun_we_observables","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.trun_we_observables","text":"trun_we_observables(E₀, B₀, sampler, n_we_steps, observables)\n\nRun a multithreaded WE simulation, returning the values a specified fucntions, observables, along the trajecotry.\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\nobservables - Tuple of scalar observable functions for the ergodic average\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.trun_we!","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.trun_we!","text":"trun_we!(E, B, sampler, n_we_steps)\n\nRun an in place multithreaded WE simulation with\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\n\n\n\n\n","category":"function"},{"location":"we1/#Distributed-Methods","page":"Weighted Ensemble Methods","title":"Distributed Methods","text":"","category":"section"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"These methods make use of distributed computation in the mutation step via pmap.","category":"page"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"prun_we\nprun_we_observables\nprun_we!","category":"page"},{"location":"we1/#WeightedEnsemble.prun_we","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.prun_we","text":"prun_we: Run a parallel WE simulation, optionally returning the ensemble at each step. This performs the mutation steps in parallel, and assumes a worker pool has already been created.\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\nOptional Arguments\n\nn_save_iters = 1 - save the ensemble and bins every n_save_iters iterations.  Set n_save_iters=n_we_steps to only save the final values.\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.prun_we_observables","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.prun_we_observables","text":"prun_we_observables: Run a parallel WE simulation, optionally returning the ensemble at each step. This performs the mutation steps in parallel, and assumes a worker pool has already been created.\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\nobservables - Tuple of scalar observable functions for the ergodic average\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.prun_we!","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.prun_we!","text":"prun_we!: Run an in place parallel WE simulation.  This performs the mutation steps in parallel, and assumes a worker pool has already been created.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\n\n\n\n\n","category":"function"},{"location":"allocation1/#Allocation","page":"Allocation","title":"Allocation","text":"","category":"section"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"Pages = [\"allocation1.md\"]","category":"page"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"The allocation methods determine:","category":"page"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"How many particles we should attempt to have within each bin.  \nHow many offspring each particle should have. ","category":"page"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"In the methods included here, one first allocates the number of particles to each bin, and then uses multinomial resampling, within each bin, to determine how many offspring each particle should have.  ","category":"page"},{"location":"allocation1/#Bin-Allocation-Methods","page":"Allocation","title":"Bin Allocation Methods","text":"","category":"section"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"    minimal_bin_allocation!","category":"page"},{"location":"allocation1/#WeightedEnsemble.minimal_bin_allocation!","page":"Allocation","title":"WeightedEnsemble.minimal_bin_allocation!","text":"minimal_bin_allocation!(B; νmin=νmin)\n\nAllocates a single particle to be spawned within each nonempty bin and the current number of particles in any bin with less than νmin total mass.\n\nArguments\n\nB - bin data structure\n\nOptional Arguments\n\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"    uniform_bin_allocation!","category":"page"},{"location":"allocation1/#WeightedEnsemble.uniform_bin_allocation!","page":"Allocation","title":"WeightedEnsemble.uniform_bin_allocation!","text":"uniform_bin_allocation!(B, E, n_allocate; allocation_resampler=systematic, νmin=νmin)\n\nUniformly allocate particles amongst bins.\n\nArguments\n\nB - bin data structure\nE - particle ensemble\nn_allocate - number of particles to allocate\n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"    optimal_bin_allocation!","category":"page"},{"location":"allocation1/#WeightedEnsemble.optimal_bin_allocation!","page":"Allocation","title":"WeightedEnsemble.optimal_bin_allocation!","text":"optimal_bin_allocation!(B, E, v², t, n_allocate; allocation_resampler=systematic, νmin=νmin)\n\nOptimally particles according to the bins, using a value function, v² to approximate mutation variance.\n\nArguments\n\nB - bin data structure\nE - particle ensemble\nv² - v² variance function estimator\nt - t-th seletion step\nn_allocate - number of particles to allocate \n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"This function is defined in the spirit of the optimal allocation analysis of Aristoff & Zuckerman (2020).","category":"page"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"    targeted_bin_allocation!","category":"page"},{"location":"allocation1/#WeightedEnsemble.targeted_bin_allocation!","page":"Allocation","title":"WeightedEnsemble.targeted_bin_allocation!","text":"targeted_bin_allocation!(B::TB, E::TE, G::F, t::Int, n_allocate::Int; allocation_resampler=systematic, νmin=νmin) where {TE<:Ensemble,TB<:Bins,F<:Function}\n\nTargeted allocation of particles amongst bins using a specified function, G:(p, E, B, t) → [0,∞) for bin p.\n\nArguments\n\nB - bin data structure\nE - particle ensemble\nG - target function\nt - t-th seletion step\nn_allocate - number of particles to allocate\nOptional Arguments\nallocation_resampler=systematic - resampling scheme amongst bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"allocation1/#Particle-Allocation-Methods","page":"Allocation","title":"Particle Allocation Methods","text":"","category":"section"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"    within_bin_allocation!","category":"page"},{"location":"allocation1/#WeightedEnsemble.within_bin_allocation!","page":"Allocation","title":"WeightedEnsemble.within_bin_allocation!","text":"within_bin_allocation!(E, B; within_bin_resampler=multinomial)\n\nOnce the number of offspring within each bin are set, allocate them amongst the particles within the bin.  This assumes that the bin allocations of the bins have completed.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\n\nOptional Arguments\n\nwithin_bin_resampler=multinomial - resampling scheme within bins\n\n\n\n\n\n","category":"function"},{"location":"allocation1/#Utility-Functions","page":"Allocation","title":"Utility Functions","text":"","category":"section"},{"location":"allocation1/","page":"Allocation","title":"Allocation","text":"    trivial_allocation!","category":"page"},{"location":"allocation1/#WeightedEnsemble.trivial_allocation!","page":"Allocation","title":"WeightedEnsemble.trivial_allocation!","text":"trivial_allocation!(E, B)\n\nTrivially allocate each particle to have one offspring.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\n\n\n\n\n\n","category":"function"},{"location":"coarse1/#Coarse-Models","page":"Coarse Modeling","title":"Coarse Models","text":"","category":"section"},{"location":"coarse1/","page":"Coarse Modeling","title":"Coarse Modeling","text":"TBW","category":"page"},{"location":"resampling1/#Resampling","page":"Resampling","title":"Resampling","text":"","category":"section"},{"location":"resampling1/","page":"Resampling","title":"Resampling","text":"As it is neccessary to perform resampling, both for determining how many offspring each bin should have, and, having determined that, resampling the particles within each bin, we have provided several choices here.  These methods, and their properties, can be found in Douc et al. (2005).  The provided selection! functions default to using WeightedEnsemble.systematic across bins and WeightedEnsemble.multinomial within bins.","category":"page"},{"location":"resampling1/","page":"Resampling","title":"Resampling","text":"All of these resampling methods take as their arguments, n, the number of trials, and ω, a vector of probabilities.  What is returned is a vector, Nvals, the same size as ω, containing the number allocated to each of the states.  These will satisfy the properties that sum(Nvals)=n, and the mean value of Nvals[i] (from repeated independent trials), is n * ω[i] for each i.","category":"page"},{"location":"resampling1/","page":"Resampling","title":"Resampling","text":"WeightedEnsemble.residual\nWeightedEnsemble.stratified\nWeightedEnsemble.systematic\nWeightedEnsemble.multinomial","category":"page"},{"location":"resampling1/#WeightedEnsemble.residual","page":"Resampling","title":"WeightedEnsemble.residual","text":"residual(n,ω)\n\nPerform residual sampling\n\nArguments\n\nn - number of trials\nω - probabilities\n\n\n\n\n\n","category":"function"},{"location":"resampling1/#WeightedEnsemble.stratified","page":"Resampling","title":"WeightedEnsemble.stratified","text":"stratified(n,ω)\n\nPerform stratified sampling\n\nArguments\n\nn - number of trials\nω - probabilities\n\n\n\n\n\n","category":"function"},{"location":"resampling1/#WeightedEnsemble.systematic","page":"Resampling","title":"WeightedEnsemble.systematic","text":"systematic(n,ω)\n\nPerform systematic sampling\n\nArguments\n\nn - number of trials\nω - probabilities\n\n\n\n\n\n","category":"function"},{"location":"resampling1/#WeightedEnsemble.multinomial","page":"Resampling","title":"WeightedEnsemble.multinomial","text":"multinomial(n, ω)\n\nPerform multinomial sampling\n\nArguments\n\nn - number of trials\nω - probabilities\n\n\n\n\n\n","category":"function"},{"location":"selection1/#Selection","page":"Selection","title":"Selection","text":"","category":"section"},{"location":"selection1/","page":"Selection","title":"Selection","text":"Pages = [\"selection1.md\"]","category":"page"},{"location":"selection1/#Details-of-the-Selection-Step","page":"Selection","title":"Details of the Selection Step","text":"","category":"section"},{"location":"selection1/","page":"Selection","title":"Selection","text":"The selection step, encoded in a user defined selection! function, is the essential element of WE.  It is designed to ensure that the results of WE are unbiased and work to reduce the variance of some QoI.  ","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"Generically, when we call selection!(E, B, t), at algorthmic step t, we advance from (omega_t^i xi_t^i (before selection) to (hatomega_t^i hatxi_t^i (after selection).  ","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"For algorithmic consistency and numerical stability, the selection step typically includes the following two conditions:","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"Every non-empty bin must have at least one offspring.  Thus, if u_p is occupied before selection (there exists i such that xi_t^i in u_p), then after selection, there exists hati such that hatxi_t^hati in u_p.  Hence, if we have a total of N particles, and K nonempty bins, we immediately allocate 1 particle to each of the nonempty bins, and then must allocate the remaining N-K particles.\nIf the total mass in a bin falls beneath some threshold, nu_t^p leq nu_min, then the number of offspring of that bin equals the number of particles currently in the bin:\nn_t^p = sum_xi_t^i in mathcalB_p 1 = sum_hatxi_t^i in mathcalB_p1\nThis is neccessary to avoid floating point underflow issues.","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"These steps are both handled by minimal_bin_allocation!(E, B).  After this step is completed, the remaining  particles are allocated to the bins, then particles are allocated within each bin, and, finally, repopulate!(E, B) is called, which assigns (hatomega_t^i hatxi_t^i), storing them in E.ξ̂ and E.ω̂.","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"Indeed, the typical user defined selection step is the composition of some number of allocation steps, discussed in Allocation, which determine the target number of particles within each bin, and the, within each bin, target number of offspring of each particle.  This is followed by the repopulate! step, which actually duplicates particles as appropriate. We have included several resampling schemes that are invoked by the allocation functions; see  Resampling.","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"As several of the included selection routines show, one may include additional arguments.  But when the selection! step is used to define a WEsampler structure, it must be such that it only takes as arguments (E,B,t).  For instance, if we want to use targeted_selection!, we need to define a target function, ","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"selection! = (E, B, t) -> targeted_selection!(E, B, G, t);\nsampler = WEsampler(mutation!, selection!, rebin!); # mutation! and rebin! defined elsewhere","category":"page"},{"location":"selection1/#Included-Selection-Methods","page":"Selection","title":"Included Selection Methods","text":"","category":"section"},{"location":"selection1/","page":"Selection","title":"Selection","text":"uniform_selection!","category":"page"},{"location":"selection1/#WeightedEnsemble.uniform_selection!","page":"Selection","title":"WeightedEnsemble.uniform_selection!","text":"uniform_selection!(E, B, t; allocation_resampler=systematic, within_bin_resampler=multinomial, νmin=νmin)\n\nUniformly select particles, ensuring each bin with positive bin weight has at least one offspring.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nt - t-th seletion step\n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nwithin_bin_resampler=multinomial - resampling scheme within bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection1/","page":"Selection","title":"Selection","text":"Uniform selection is suboptimal (in the sense of variance reduction), but provided there are a sufficient number of bins and particles, it can often provide quite satisfactory results.  It has the advantage of being very straightforward to implement.  ","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"optimal_selection!","category":"page"},{"location":"selection1/#WeightedEnsemble.optimal_selection!","page":"Selection","title":"WeightedEnsemble.optimal_selection!","text":"optimal_selection!(E, B, v², t; allocation_resampler=systematic, within_bin_resampler=multinomial, νmin=νmin))\n\nPerform optimal selection of the particles, ensuring each non empty bin has at least one particle.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nv² - v² variance function estimator\nt - t-th seletion step\n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nwithin_bin_resampler=multinomial - resampling scheme within bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection1/","page":"Selection","title":"Selection","text":"Optimal selection is taken from Aristoff & Zuckerman (2020), where particles are allocated to bins according to ","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"fracC_t(u)N propto nu_t sqrtsum_xi_t^imid iin ufracomega_t^inu_tv^2(xi_t^it)","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"For steady state problems ","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"v^2(xi t) = v^2(xi) =mathrmVar_K(xibullet)(h)","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"where h solves the Poisson equation,","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"(I-K)h = f - mu(f)","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"This of course, must be estimated, and tools are provided for this in Coarse Models","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"targeted_selection!","category":"page"},{"location":"selection1/#WeightedEnsemble.targeted_selection!","page":"Selection","title":"WeightedEnsemble.targeted_selection!","text":"targeted_selection!(E, B, G, t; ; allocation_resampler=systematic, within_bin_resampler=multinomial, νmin=νmin))\n\nPerform targeted selection of the particles, ensuring each non empty bin has at least one particle.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nG(p, E, B, t) - target function, applied to bin index p\nt - t-th seletion step\n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nwithin_bin_resampler=multinomial - resampling scheme within bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection1/","page":"Selection","title":"Selection","text":"Targeted selection allows one steer bin allocation according to the rule","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"fracC_t(u)N propto G(u)","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"where the target function, G, is of the form G(p, E, B, t), with bin index p.  ","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"static_selection!","category":"page"},{"location":"selection1/#WeightedEnsemble.static_selection!","page":"Selection","title":"WeightedEnsemble.static_selection!","text":"static_selection!(E, B, n_static, t; within_bin_resampler=multinomial, νmin=νmin)\n\nSelect particles according to a static allocation rule.  \n\nArguments\n\nE - particle ensemble\nB - bin data structure\nn_static - array of predetermined bin allocation numbers\nt - t-th seletion step\n\nOptional Arguments\n\nwithin_bin_resampler=multinomial - resampling scheme within bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection1/","page":"Selection","title":"Selection","text":"Static selection allows one to predetermine the target number of particles in each bin by providing a vector n_static.  It is assumed n_static[i]>0 and sum(n_static)≤N.  It may be that fewer than N particles are allocated.  In this case, some of the offspring will be given zero mass.","category":"page"},{"location":"selection1/","page":"Selection","title":"Selection","text":"trivial_selection!","category":"page"},{"location":"selection1/#WeightedEnsemble.trivial_selection!","page":"Selection","title":"WeightedEnsemble.trivial_selection!","text":"trivial_selection!(E)\n\nTrivial selection, copying over particles\n\nArguments\n\nE - particle ensemble\n\n\n\n\n\n","category":"function"},{"location":"selection1/","page":"Selection","title":"Selection","text":"This a convenience tool built in which (omega_t^i xi_t^i=(hatomega_t^i hatxi_t^i.  It can be useful when benchmarking against the non-interacting particle system case.","category":"page"},{"location":"#WeightedEnsemble.jl","page":"Home","title":"WeightedEnsemble.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 2","category":"page"},{"location":"#Algorithm-Overview","page":"Home","title":"Algorithm Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 3:4","category":"page"},{"location":"","page":"Home","title":"Home","text":"Weighted Ensemble (WE) is a variance reduction strategy that can be used to, amongst other things, estimate rare events.  More generally, it is designed to estimate","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbbE_muf(X) = mu(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"for some Quantity of Interest (QoI), f, with respect to some target measure, mu.   One of the major advantages of WE  over other variance reduction strategies is that it makes rather minimal assumptions on the Markov underlying process.  Indeed, there is no assumption of reversibility of the process, nor is there any need to evaluate or otherwise estimate a likelihood.  It is sufficient to be able to simulate the associated process, i.e., sample a Markov kernel, K, for which mu is the stationary distribution.  A key application of this approach is in the computation of mean first passage times (MFPTs) via the Hill relation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This implementation of WE makes use of a fixed number, N, particles, xi^i, each carrying weight omega^i.  At algorithmic time t, we denote","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu_t^N(dx) = sum_i=1^N omega_t^idelta_xi_t^i(dx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The weights are assumed to be positive and sum to one.  The particle ensemble is stored in an Ensemble data structure. The ensemble is evolved, successively, in two steps, selection and mutation.  As the partilces and weights evolve in time, we add a t subscript to indicate that these quantities change, (omega_t^ixi_t^i.","category":"page"},{"location":"#Selection","page":"Home","title":"Selection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"During the selection step, particles are resampled from the empirical distribution in such a way so as to maintain unbiasedness and reduce variance with respect to some quantity of interest.  The ensemble after selection is represented by","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatmu_t^N(dx) = sum_i=1^N hatomega_t^idelta_hatxi_t^i(dx)","category":"page"},{"location":"#Bins","page":"Home","title":"Bins","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To understand more of how the selection step works, it is essential to introduce the concept of bins.  Indeed, this implementation of WE is bin based, in the following sense.  The indices of the particles are partitioned into bins, u_1 u_2ldots u_M, where M is the number of partitions.  Often, these bins are determined by a disjoint partition of the state space, mathcalX as","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalX = bigcup_i=1^M mathcalB_i quad j in u_i leftrightarrow xi_t^jin mathcalB_i","category":"page"},{"location":"","page":"Home","title":"Home","text":"Though the presentation here assumes that the bins are statically (independent of t), these need not be the case in general.  Associated with each bin is the particle count at time t, n_t^i=u_i, and the bin weight, nu_t^i, given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"nu^i_t = sum_jin u_iomega^j","category":"page"},{"location":"","page":"Home","title":"Home","text":"The bins and their features are recorded in a Bins data structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To perform the selection step, one first performs the allocation steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, we determine how many particles should reside in each of the bins, C_t(u), after selection.  This is implemented to satisfy total particle conservation","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_i=1^MC_t(u_i) = N","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple, though suboptimal, choice is uniform allocation, in which C_t(u_i)approx 1M.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Second, we determine how many offspring each particle should have.  This is implemented to constrain the bin count from the first step,","category":"page"},{"location":"","page":"Home","title":"Home","text":"C_t(u_i)=sum_jin u_iC_t^j","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is typically done using multinomial resampling, with","category":"page"},{"location":"","page":"Home","title":"Home","text":"(C_t^j_k) sim mathrmMultileft(C_t(u_i)fracomega_t^j_1nu_t^ifracomega_t^j_2nu_t^ildots right)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the j_k in u_i.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Having allocated the number of offspring to each particle, we then repopulate our ensemble as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Offspring of particle xi_t^j are assigned this as their position;\nOffspring of particles in bin u_i are all assigned weight nu_t^iC_t(u_i).","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are some additional subtlesties that are implemented to ensure the allocation and selection with bins behaves as expected.","category":"page"},{"location":"#Mutation","page":"Home","title":"Mutation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"During the mutation step, the particles evolve freely over one algorithmic time unit according to a user defined Markov kernel, K, with xi_t+1^isim K(hatxi_t^i dx), and omega_t+1^i= hatomega_t^i.  We then have the updated ensemble,","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu_t+1^N(dx) = sum_i=1^N omega_t+1^idelta_xi_t+1^i(dx)","category":"page"},{"location":"#Unbiasedness","page":"Home","title":"Unbiasedness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repeating the above alternating selection/mutation steps, the key feature of WE is as follows. Denote by mu the invariant measure associated with the Markov kernel K such that mu K=mu.  Additionally, suppose omega_0^i=1N and xi_0^isim mu_0 be i.i.d.  Lastly, denote by mu_t = mu_0 K^t.  Then for any observable f,","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu_t(f)=mathbbE_mu_0f(X_t) = mathbbEmu_t^N(f)= mathbbEhatmu_t^N(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the latter two expectations are ensemble averages over the WE process.  Consequently, WE is unbiased, and it is providing N-particle approximations of the distribution, mu_t.","category":"page"},{"location":"#Estimation","page":"Home","title":"Estimation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WE can thus be used to compute averages against the associated a target stationary measure, mu, in the usual way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu(f) = lim_ttoinfty mu_t(f)= lim_tto inftyfrac1tsum_s=0^t-1 mu_s(f) = lim_tto inftyfrac1tsum_s=0^t-1 mu^N_s(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is what we will use to make estimates; by taking t sufficiently large,","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu(f) approx frac1tsum_s=0^t-1 mu^N_s(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A key thing to note is that WE does not accelerate mixing.  The mixing rate is controlled by the underlying Markov process.  What WE does do is, ideally, provide very low variance estimates of mu_t(f).  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"WE can also be used to estimate finite time non-equilibrium quantities.","category":"page"},{"location":"#Implementation","page":"Home","title":"Implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To run WE, we must define a WEsampler sampler, which defines the above steps.  Indeed, to recap, one must code up steps for","category":"page"},{"location":"","page":"Home","title":"Home","text":"selection!(E, B, t) - This is an in place transform that modifies the ensemble, E, and the bins B.  It may be time dependent.\nmutation!(ξ) - This is an in place transform corresponds to the application of the Markov kernel to the state, xi sim K(xibullet).  Though this operation is vectorized, it does defined on the underlying state space, not the ensemble or bin structures.  It is assumed to be time homogeneous.\nsampler.rebin!(E, B, t+1) - This is applied after mutation, at time t+1, and determines which particles are in which bins, updating the structures accordingly.  It also retabulates the weight, nu_t^i of each bin.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Having defined a sampler structure and provided initial E0 ensemble and B0 bins structures, WE is then executed with the command","category":"page"},{"location":"","page":"Home","title":"Home","text":"n_we_steps = 10; \nE_trajectory, B_trajectory = run_we(E0, B0, sampler, n_we_steps);","category":"page"},{"location":"","page":"Home","title":"Home","text":"The data structures contain, amongst other things,:","category":"page"},{"location":"","page":"Home","title":"Home","text":"E_trajctory - (omega_t^i xi_t^i, (hatomega_t^i hatxi_t^i;\nB_trajectory - n_t^i, nu_t^i.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These can be used to compute the QoI.","category":"page"},{"location":"#Caveats","page":"Home","title":"Caveats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is some partial parallelization implemented, both with threads and with Distributed.  In both cases, the parallelization is only with respect to the application of the mutation! step, presumed to be the most costly piece of the algorithm.  It does not currently make use of distributed data structures or parallelize the selection step.","category":"page"},{"location":"#Collaborators","page":"Home","title":"Collaborators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"D. Aristoff\nJ. Copperman\nL. F. Doherty\nF. G. Jones\nR. J. Webber\nD. M. Zuckerman","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was supported in part by the US National Science Foundation Grants DMS-1818716 and DMS-2111278.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Aristoff, D., Copperman, J., Simpson, G., Webber, R. J. & Zuckerman, D. M. Weighted ensemble: Recent mathematical developments. J. Chem. Phys. 158, 014108 (2023).\nRusso, J. D. et al. WESTPA 2.0: High-Performance Upgrades for Weighted Ensemble Simulations and Analysis of Longer-Timescale Applications. J. Chem. Theory Comput. 18, 638–649 (2022).\nAristoff, D. An ergodic theorem for the weighted ensemble method. arXiv:1906.00856 (2021).\nWebber, R. J., Aristoff, D., & Simpson, G. A splitting method to reduce MCMC variance. arXiv:2011.13899 (2020)\nAristoff, D. & Zuckerman, D. M. Optimizing Weighted Ensemble Sampling of Steady States. Multiscale Model. Simul. 18, 646–673 (2020).\nHuber, G. A. & Kim, S. Weighted-ensemble Brownian dynamics simulations for protein association reactions. Biophysical Journal 70, 97–110 (1996).\nDouc, R. & Cappe, O. Comparison of resampling schemes for particle filtering. in ISPA 2005. Proceedings of the 4th International Symposium on Image and Signal Processing and Analysis, 2005. 64–69 (IEEE, Zagreb, Croatia, 2005). doi:10.1109/ISPA.2005.195385.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"util1/#Utility-Functions","page":"Utility Functions","title":"Utility Functions","text":"","category":"section"},{"location":"util1/","page":"Utility Functions","title":"Utility Functions","text":"Some additional functions have been provided that, while they are not directly  used, may be of use to the user.","category":"page"},{"location":"util1/","page":"Utility Functions","title":"Utility Functions","text":"WeightedEnsemble.update_bin_weights!\nWeightedEnsemble.trivial_analysis!\nWeightedEnsemble.Voronoi_bin_id\nrepopulate!","category":"page"},{"location":"util1/#WeightedEnsemble.update_bin_weights!","page":"Utility Functions","title":"WeightedEnsemble.update_bin_weights!","text":"update_bin_weights!(B, E)\n\nUpdate the bin weights and bin particle counts from the ensemble\n\nArguments\n\nB - bin data structure\nE - particle ensemble\n\n\n\n\n\n","category":"function"},{"location":"util1/#WeightedEnsemble.trivial_analysis!","page":"Utility Functions","title":"WeightedEnsemble.trivial_analysis!","text":"trivial_analysis!(E, B, t)\n\nDefault, trivial, analysis! step.\n\n\n\n\n\n","category":"function"},{"location":"util1/#WeightedEnsemble.Voronoi_bin_id","page":"Utility Functions","title":"WeightedEnsemble.Voronoi_bin_id","text":"Voronoi_bin_id(X, tree)\n\nConvenience function for bin id in Voronoi based bins\n\nArguments\n\nX - Point thats bin is to be determined\ntree - A nearest neighbors tree structure constructed with KDTree\n\n\n\n\n\n","category":"function"},{"location":"util1/#WeightedEnsemble.repopulate!","page":"Utility Functions","title":"WeightedEnsemble.repopulate!","text":"repopulate!(E, B)\n\nAfter allocating the number of offspring of each particle, copy the particles over.  If the number of allocated particles is < N, the remaining particles are assigned zero weight.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\n\n\n\n\n\n","category":"function"}]
}
