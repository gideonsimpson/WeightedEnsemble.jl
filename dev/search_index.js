var documenterSearchIndex = {"docs":
[{"location":"struct1/#Data-Structures-for-Weighted-Ensemble","page":"Structures","title":"Data Structures for Weighted Ensemble","text":"","category":"section"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Pages = [\"struct1.md\"]","category":"page"},{"location":"struct1/#Ensembles","page":"Structures","title":"Ensembles","text":"","category":"section"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Ensemble","category":"page"},{"location":"struct1/#WeightedEnsemble.Ensemble","page":"Structures","title":"WeightedEnsemble.Ensemble","text":"Ensemble{TP, TF<:AbstractFloat, TI<:Integer, TD}\n\nA particle ensemble structure designed for WE with bins.\n\nFields\n\nξ̂ - particle positions after selection, before mutation\nξ - particle positions after mutation\nω̂ - partice weights after selection, before mutation\nω - partice weights after mutation\nb̂ - particle bin after selection, before mutation\nb - particle bin after mutation\no - number of offspring of the particle\nd̂ - auxiliary data for each particle after selection, before mutation\nd - auxiliary data for each particle, after mutation\n\n\n\n\n\n","category":"type"},{"location":"struct1/","page":"Structures","title":"Structures","text":"The ensemble data structure holds the information about (omega_t^(i) xi_t^(i), along with the post selection step (hatomega_t^(i) hatxi_t^(i).  Fo convenience, it also carries information about the bin the particle currently resides in.  The structures d and d̂ are optional for carrying any auxiliary information.","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"A convenience constructor has been included in the case that mu_0=delta_x_0:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Dirac_to_Ensemble","category":"page"},{"location":"struct1/#WeightedEnsemble.Dirac_to_Ensemble","page":"Structures","title":"WeightedEnsemble.Dirac_to_Ensemble","text":"Dirac_to_Ensemble(X, n_particles; d = Nothing())\n\nConvenience function for construction an ensemble from a single initial walker.  This hard codes the weights to be Float64.\n\nArguments\n\nX - Starting state of all walkers\n\n*n_particles - Number of walkers in the ensemble\n\nOptional Arguments\n\nd = Nothing()) - optional auxliary data\n\n\n\n\n\n","category":"function"},{"location":"struct1/","page":"Structures","title":"Structures","text":"As an example, if our problem is posed in mathbbR, an initial ensemble could be constructed:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"x0 = [-1.0];\nn_particles = 100;\nE0 = Dirac_to_Ensemble(x0, n_particles);","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"This initializes the bin id field, b, to zeros.  It will be neccessary to either manually assign this field, or to call the user defined rebin! function:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"rebin!(E0, B0, 0);","category":"page"},{"location":"struct1/#Bins","page":"Structures","title":"Bins","text":"","category":"section"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Bins","category":"page"},{"location":"struct1/#WeightedEnsemble.Bins","page":"Structures","title":"WeightedEnsemble.Bins","text":"Bins{TS, TW, TBI, TT}\n\nA bin structure designed for WE\n\nFields\n\nΩ - structure containing information for uniquely identifying each bin\nn - number of particles in each bin\ntarget - target number of particles in each bin\nν - weight of each bin\nd - auxiliary bin data\n\n\n\n\n\n","category":"type"},{"location":"struct1/","page":"Structures","title":"Structures","text":"In addition to defining the Bins data strucutre, it will also be essential to provide:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"bin_id(x) - This maps points in the state space to an integer indexing fo the bins.\nrebin!(E, B, t) - This determines the bin of each particle, records this in the ensemble E.b field, sums the weights of all particles within the bins, and updates this in the bins B.ν field.  This may be time dependent.","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"Several tools have been provided to simplify the construction of the bins.  ","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"WeightedEnsemble.Points_to_Bins","category":"page"},{"location":"struct1/#WeightedEnsemble.Points_to_Bins","page":"Structures","title":"WeightedEnsemble.Points_to_Bins","text":"Points_to_Bins(points; d = Nothing())\n\nConvenience function for constructing a bin structure identified by a sequence of points.\n\nArguments\n\npoints - An array of points that can be used to define Voronoi cells\n\nOptional Arguments\n\nd = Nothing()) - optional auxliary data ``\n\n\n\n\n\n","category":"function"},{"location":"struct1/","page":"Structures","title":"Structures","text":"This is useful if the bins can be sensibily identified with a set of points in the state space, as in the case of a Voronoi tesselation.  Indeed, as Voronoi tesselations are often used, we have","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"setup_Voronoi_bins","category":"page"},{"location":"struct1/#WeightedEnsemble.setup_Voronoi_bins","page":"Structures","title":"WeightedEnsemble.setup_Voronoi_bins","text":"setup_Voronoi_bins(voronoi_pts; d = Nothing())\n\nConvenience function for constructing bins, a bin id function, and a rebinning function based on a set of Voronoi points\n\nArguments\n\nvoronoi_pts - User specified Voronoi cell centers\n\nOptional Arguments\n\nd = Nothing()) - optional auxliary data \n\n\n\n\n\n","category":"function"},{"location":"struct1/","page":"Structures","title":"Structures","text":"As an example, suppose our Voronoi bins are points in mathbbR^2, then the following code will produce all the needed functions:","category":"page"},{"location":"struct1/","page":"Structures","title":"Structures","text":"voronoi_centers = [[-1.0, -2.0], [2.0, 1.0], [1.0, 0.]];\nB0, bin_id, rebin! = setup_Voronoi_bins(voronoi_centers);","category":"page"},{"location":"struct1/#Samplers","page":"Structures","title":"Samplers","text":"","category":"section"},{"location":"struct1/","page":"Structures","title":"Structures","text":"WEsampler","category":"page"},{"location":"struct1/#WeightedEnsemble.WEsampler","page":"Structures","title":"WeightedEnsemble.WEsampler","text":"WEsampler(mutation!, selection!, rebin!; analysis! = trivial_analysis!)\n\nArguments\n\nmutation! - mutation step\nselection! - selection step\nrebin! - rebinning step\n\nOptional Arguments\n\nanalysis! = trivial_analysis! - analysis step\n\n\n\n\n\n","category":"type"},{"location":"selection/selection1/#Selection-Algorithms","page":"Selection Algorithms","title":"Selection Algorithms","text":"","category":"section"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"Pages = [\"selection1.md\"]","category":"page"},{"location":"selection/selection1/#Details-of-the-Selection-Step","page":"Selection Algorithms","title":"Details of the Selection Step","text":"","category":"section"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"The selection step, encoded in a user defined selection! function, is the essential element of WE.  It is designed to ensure that the results of WE are unbiased and work to reduce the variance of some QoI.  ","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"Generically, when we call selection!(E, B, t), at algorthmic step t, we advance from (omega_t^i xi_t^i (before selection) to (hatomega_t^i hatxi_t^i (after selection).  ","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"For algorithmic consistency and numerical stability, the selection step typically includes the following two conditions:","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"Every non-empty bin must have at least one offspring.  Thus, if u_p is occupied before selection (there exists i such that xi_t^i in u_p), then after selection, there exists hati such that hatxi_t^hati in u_p.  Hence, if we have a total of N particles, and K nonempty bins, we immediately allocate 1 particle to each of the nonempty bins, and then must allocate the remaining N-K particles.\nIf the total mass in a bin falls beneath some threshold, nu_t^p leq nu_min, then the number of offspring of that bin equals the number of particles currently in the bin:\nn_t^p = sum_xi_t^i in mathcalB_p 1 = sum_hatxi_t^i in mathcalB_p1\nThis is neccessary to avoid floating point underflow issues.","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"These steps are both handled by minimal_bin_allocation!(E, B).  After this step is completed, the remaining  particles are allocated to the bins, then particles are allocated within each bin, and, finally, repopulate!(E, B) is called, which assigns (hatomega_t^i hatxi_t^i), storing them in E.ξ̂ and E.ω̂.","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"Indeed, the typical user defined selection step is the composition of some number of allocation steps, discussed in Allocation Algorithms, which determine the target number of particles within each bin, and the, within each bin, target number of offspring of each particle.  This is followed by the repopulate! step, which actually duplicates particles as appropriate. We have included several resampling schemes that are invoked by the allocation functions; see  Resampling Algorithms.","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"As several of the included selection routines show, one may include additional arguments.  But when the selection! step is used to define a WEsampler structure, it must be such that it only takes as arguments (E,B,t).  For instance, if we want to use targeted_selection!, we need to define a target function, ","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"selection! = (E, B, t) -> targeted_selection!(E, B, G, t);\nsampler = WEsampler(mutation!, selection!, rebin!); # mutation! and rebin! defined elsewhere","category":"page"},{"location":"selection/selection1/#Selection-Methods","page":"Selection Algorithms","title":"Selection Methods","text":"","category":"section"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"uniform_selection!","category":"page"},{"location":"selection/selection1/#WeightedEnsemble.uniform_selection!","page":"Selection Algorithms","title":"WeightedEnsemble.uniform_selection!","text":"uniform_selection!(E, B, t; allocation_resampler=systematic, within_bin_resampler=multinomial, νmin=νmin)\n\nUniformly select particles, ensuring each bin with positive bin weight has at least one offspring.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nt - t-th seletion step\n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nwithin_bin_resampler=multinomial - resampling scheme within bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"Uniform selection is suboptimal (in the sense of variance reduction), but provided there are a sufficient number of bins and particles, it can often provide quite satisfactory results.  It has the advantage of being very straightforward to implement.  ","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"optimal_selection!","category":"page"},{"location":"selection/selection1/#WeightedEnsemble.optimal_selection!","page":"Selection Algorithms","title":"WeightedEnsemble.optimal_selection!","text":"optimal_selection!(E, B, v², t; allocation_resampler=systematic, within_bin_resampler=multinomial, νmin=νmin))\n\nPerform optimal selection of the particles, ensuring each non empty bin has at least one particle.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nv² - v² variance function estimator\nt - t-th seletion step\n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nwithin_bin_resampler=multinomial - resampling scheme within bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"Optimal selection is taken from Aristoff & Zuckerman (2020), where particles are allocated to bins according to ","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"fracC_t(u)N propto nu_t sqrtsum_xi_t^imid iin ufracomega_t^inu_tv^2(xi_t^it)","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"For steady state problems ","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"v^2(xi t) = v^2(xi) =mathrmVar_K(xibullet)(h)","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"where h solves the Poisson equation,","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"(I-K)h = f - mu(f)","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"This of course, must be estimated, and tools are provided for this in Coarse Models","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"targeted_selection!","category":"page"},{"location":"selection/selection1/#WeightedEnsemble.targeted_selection!","page":"Selection Algorithms","title":"WeightedEnsemble.targeted_selection!","text":"targeted_selection!(E, B, G, t; ; allocation_resampler=systematic, within_bin_resampler=multinomial, νmin=νmin))\n\nPerform targeted selection of the particles, ensuring each non empty bin has at least one particle.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nG(p, E, B, t) - target function, applied to bin index p\nt - t-th seletion step\n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nwithin_bin_resampler=multinomial - resampling scheme within bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"Targeted selection allows one steer bin allocation according to the rule","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"fracC_t(u)N propto G(u)","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"where the target function, G, is of the form G(p, E, B, t), with bin index p.  ","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"static_selection!","category":"page"},{"location":"selection/selection1/#WeightedEnsemble.static_selection!","page":"Selection Algorithms","title":"WeightedEnsemble.static_selection!","text":"static_selection!(E, B, n_static, t; within_bin_resampler=multinomial, νmin=νmin)\n\nSelect particles according to a static allocation rule.  \n\nArguments\n\nE - particle ensemble\nB - bin data structure\nn_static - array of predetermined bin allocation numbers\nt - t-th seletion step\n\nOptional Arguments\n\nwithin_bin_resampler=multinomial - resampling scheme within bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"Static selection allows one to predetermine the target number of particles in each bin by providing a vector n_static.  It is assumed n_static[i]>0 and sum(n_static)≤N.  It may be that fewer than N particles are allocated.  In this case, some of the offspring will be given zero mass.","category":"page"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"trivial_selection!","category":"page"},{"location":"selection/selection1/#WeightedEnsemble.trivial_selection!","page":"Selection Algorithms","title":"WeightedEnsemble.trivial_selection!","text":"trivial_selection!(E)\n\nTrivial selection, copying over particles\n\nArguments\n\nE - particle ensemble\n\n\n\n\n\n","category":"function"},{"location":"selection/selection1/","page":"Selection Algorithms","title":"Selection Algorithms","text":"This a convenience tool built in which (omega_t^i xi_t^i=(hatomega_t^i hatxi_t^i.  It can be useful when benchmarking against the non-interacting particle system case.","category":"page"},{"location":"we1/#Weighted-Ensemble-Methods","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"","category":"section"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"Pages = [\"we1.md\"]","category":"page"},{"location":"we1/#Serial-Methods","page":"Weighted Ensemble Methods","title":"Serial Methods","text":"","category":"section"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"run_we\nrun_we_observables\nrun_we!","category":"page"},{"location":"we1/#WeightedEnsemble.run_we","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.run_we","text":"run_we(E₀, B₀, sampler, n_we_steps; n_save_iters = 1)\n\nRun a serial WE simulation, optionally returning the ensemble at each, step with\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\nOptional Arguments\n\nn_save_iters = 1 - save the ensemble and bins every n_save_iters iterations.  Set n_save_iters=n_we_steps to only save the final values.\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.run_we_observables","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.run_we_observables","text":"run_we_observables(E₀, B₀, sampler, n_we_steps, observables)\n\nRun a serial WE simulation, returning the values a specified fucntion, f, along the trajecotry.\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\nobservables - Tuple of scalar observable functions for the ergodic average\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.run_we!","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.run_we!","text":"run_we!(E, B, sampler, n_we_steps)\n\nRun an in place serial WE simulation with\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\n\n\n\n\n","category":"function"},{"location":"we1/#Multithreated-Methods","page":"Weighted Ensemble Methods","title":"Multithreated Methods","text":"","category":"section"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"These methods make use of multithreading in the mutation step.","category":"page"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"trun_we\ntrun_we_observables\ntrun_we!","category":"page"},{"location":"we1/#WeightedEnsemble.trun_we","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.trun_we","text":"trun_we(E₀, B₀, sampler, n_we_steps; n_save_iters = 1)\n\nRun a multithreaded WE simulation, optionally returning the ensemble at each, step with\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\nOptional Arguments\n\nn_save_iters = 1 - save the ensemble and bins every n_save_iters iterations.  Set n_save_iters=n_we_steps to only save the final values.\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.trun_we_observables","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.trun_we_observables","text":"trun_we_observables(E₀, B₀, sampler, n_we_steps, observables)\n\nRun a multithreaded WE simulation, returning the values a specified fucntions, observables, along the trajecotry.\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\nobservables - Tuple of scalar observable functions for the ergodic average\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.trun_we!","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.trun_we!","text":"trun_we!(E, B, sampler, n_we_steps)\n\nRun an in place multithreaded WE simulation with\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\n\n\n\n\n","category":"function"},{"location":"we1/#Distributed-Methods","page":"Weighted Ensemble Methods","title":"Distributed Methods","text":"","category":"section"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"These methods make use of distributed computation in the mutation step via pmap.","category":"page"},{"location":"we1/","page":"Weighted Ensemble Methods","title":"Weighted Ensemble Methods","text":"prun_we\nprun_we_observables\nprun_we!","category":"page"},{"location":"we1/#WeightedEnsemble.prun_we","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.prun_we","text":"prun_we: Run a parallel WE simulation, optionally returning the ensemble at each step. This performs the mutation steps in parallel, and assumes a worker pool has already been created.\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\nOptional Arguments\n\nn_save_iters = 1 - save the ensemble and bins every n_save_iters iterations.  Set n_save_iters=n_we_steps to only save the final values.\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.prun_we_observables","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.prun_we_observables","text":"prun_we_observables: Run a parallel WE simulation, optionally returning the ensemble at each step. This performs the mutation steps in parallel, and assumes a worker pool has already been created.\n\nArguments\n\nE₀ - initial particle ensemble\nB₀ - initial bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\nobservables - Tuple of scalar observable functions for the ergodic average\n\n\n\n\n\n","category":"function"},{"location":"we1/#WeightedEnsemble.prun_we!","page":"Weighted Ensemble Methods","title":"WeightedEnsemble.prun_we!","text":"prun_we!: Run an in place parallel WE simulation.  This performs the mutation steps in parallel, and assumes a worker pool has already been created.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\nsampler - WE sampler functions data structure\nn_we_steps - number of steps in the WE run\n\n\n\n\n\n","category":"function"},{"location":"util1/#Utility-Functions","page":"Utility Functions","title":"Utility Functions","text":"","category":"section"},{"location":"util1/","page":"Utility Functions","title":"Utility Functions","text":"Some additional functions have been provided that, while they are not directly  used, may be of use to the user.","category":"page"},{"location":"util1/","page":"Utility Functions","title":"Utility Functions","text":"WeightedEnsemble.update_bin_weights!\nWeightedEnsemble.trivial_analysis!\nWeightedEnsemble.Voronoi_bin_id\nrepopulate!","category":"page"},{"location":"util1/#WeightedEnsemble.update_bin_weights!","page":"Utility Functions","title":"WeightedEnsemble.update_bin_weights!","text":"update_bin_weights!(B, E)\n\nUpdate the bin weights and bin particle counts from the ensemble\n\nArguments\n\nB - bin data structure\nE - particle ensemble\n\n\n\n\n\n","category":"function"},{"location":"util1/#WeightedEnsemble.trivial_analysis!","page":"Utility Functions","title":"WeightedEnsemble.trivial_analysis!","text":"trivial_analysis!(E, B, t)\n\nDefault, trivial, analysis! step.\n\n\n\n\n\n","category":"function"},{"location":"util1/#WeightedEnsemble.Voronoi_bin_id","page":"Utility Functions","title":"WeightedEnsemble.Voronoi_bin_id","text":"Voronoi_bin_id(X, tree)\n\nConvenience function for bin id in Voronoi based bins\n\nArguments\n\nX - Point thats bin is to be determined\ntree - A nearest neighbors tree structure constructed with KDTree\n\n\n\n\n\n","category":"function"},{"location":"util1/#WeightedEnsemble.repopulate!","page":"Utility Functions","title":"WeightedEnsemble.repopulate!","text":"repopulate!(E, B)\n\nAfter allocating the number of offspring of each particle, copy the particles over.  If the number of allocated particles is < N, the remaining particles are assigned zero weight.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\n\n\n\n\n\n","category":"function"},{"location":"coarse1/#Coarse-Models","page":"Coarse Modeling","title":"Coarse Models","text":"","category":"section"},{"location":"coarse1/","page":"Coarse Modeling","title":"Coarse Modeling","text":"TBW","category":"page"},{"location":"examples/equil1/#Equilibrium-Sampling","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"","category":"section"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"These exmaples involve sampling from an equilibirum Boltzmann type distribution of the sort commonly found in molecular dynamics and Bayesian inverse problems.  ","category":"page"},{"location":"examples/equil1/#Doublewell-Potential","page":"Equilibrium Sampling","title":"Doublewell Potential","text":"","category":"section"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"As a first example, we will consider the classical double well potential,","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"V(x) = (x^2-1)^2","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"in dimension one, and its associated Boltzmann distribution,","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"mu(dx) propto e^-beta V(x)dx","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"For a sufficiently low temperature (large beta), we expect the distribution to concentrate near ±1.  ","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"Consider the question of estimating mathbbP_mu(A), where A = (-delta delta), is a set in the neighborhood of the saddle at the origin. At low temperature, this will be a rare event, mathbbP_mu(A)ll 1.  Indeed, even at β=10 and δ=0.1, we find:","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"using QuadGK\nusing TestLandscapes\nβ = 10.;\nδ = 0.1;\nf(x) = exp(-β*SymmetricDoubleWell(x))\nZ = quadgk(f, -Inf, Inf)[1];\np = quadgk(f, -δ, δ)[1]/Z;\n@show p;","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"While not the rareest of events, this will take a bit of effort to estimate with high confidence.","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"We will explore this landscape using the MALA approximation of overdamped Langevin dyanmics; thus, we build up the mutation step:","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"using ForwardDiff\nusing BasicMD\nV(x) = SymmetricDoubleWell(x[1])\n∇V! = (gradV, X) -> ForwardDiff.gradient!(gradV, V, X);\nΔt = 1e-2;  # time step\nsampler = MALA(V, ∇V!, β, Δt);\n\nnΔt = 1; # number of fine time steps per coarse WE step\n\n# define the mutation mapping\nopts = MDOptions(n_iters=nΔt);\nmutation! = x -> sample_trajectory!(x, sampler, options=opts); nothing","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"Next, we define our observable, corresponding to the indicator function on the set A:","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"fA(x) = Float64(-δ<x[1]<δ); nothing","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"Next, we select a set of bins based on a Voronoi tesselation of the real line:","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"using WeightedEnsemble\nvoronoi_pts = [[x_] for x_ in LinRange(-1.5, 1.5, 23)];\nB0, bin_id, rebin! = setup_Voronoi_bins(voronoi_pts); nothing","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"before defining the selection step, we will also set the number of particles, WE steps, and initialize an ensemble:","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"n_we_steps = 10^3;\nn_particles = 10^3;\n\nx0 = [-1.0]; # this is somewhat arbitrary\nE0 = Dirac_to_Ensemble(x0, n_particles);\nrebin!(E0, B0, 0); nothing # ensure weights are properly tabulated","category":"page"},{"location":"examples/equil1/#Uniform-Selection","page":"Equilibrium Sampling","title":"Uniform Selection","text":"","category":"section"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"In the case that we use uniform selection, we proceed with:","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"# define selection function\nuni_selection! = (E, B, t) -> uniform_selection!(E, B, t)\n# set up sampler - trivial analysis step\nuni_we_sampler = WEsampler(mutation!, uni_selection!, rebin!); nothing","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"Next, we can run and examine our results:","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"using Statistics\nusing Random # for reproducbility\nRandom.seed!(100);\nf_trajectory = run_we_observables(E0, B0, uni_we_sampler, n_we_steps, (fA,))[:]\n@show mean(f_trajectory);","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"Visualizing our computation:","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"using Plots\nplot(1:n_we_steps, cumsum(f_trajectory) ./(1:n_we_steps),label=\"Uniform\")\nplot!(1:n_we_steps, p*ones(n_we_steps),label=\"Exact\",ls=:dash, color=:black)\nxlabel!(\"Iterate\")\nylabel!(\"Running Average\")","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"This gives a fairly good estimate, but one might ask how it fares against having used the same amount of resources on the problem directly:","category":"page"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"# set up sampler - trivial analysis step\ntrivial_we_sampler = WEsampler(mutation!, (E, B, t)->trivial_selection!(E), rebin!); nothing\nf_direct_trajectory = run_we_observables(E0, B0, trivial_we_sampler, n_we_steps, (fA,))[:];\n@show mean(f_direct_trajectory);\nplot(1:n_we_steps, cumsum(f_trajectory) ./(1:n_we_steps),label=\"Uniform\")\nplot!(1:n_we_steps, cumsum(f_direct_trajectory) ./(1:n_we_steps),label=\"Direct\")\nplot!(1:n_we_steps, p*ones(n_we_steps),label=\"Exact\",ls=:dash, color=:black)\nxlabel!(\"Iterate\")\nylabel!(\"Running Average\")","category":"page"},{"location":"examples/equil1/#Optimal-Selection","page":"Equilibrium Sampling","title":"Optimal Selection","text":"","category":"section"},{"location":"examples/equil1/","page":"Equilibrium Sampling","title":"Equilibrium Sampling","text":"TBW","category":"page"},{"location":"mutation/mutation1/#mutation1","page":"Mutation","title":"Mutation","text":"","category":"section"},{"location":"mutation/mutation1/","page":"Mutation","title":"Mutation","text":"The mutation step is the user defined function corresponding to one step of a (time-independent) Markov chain, X_k+1sim K(X_kbullet).  This should be coded as an in place transform, mutation!, such that one can execute","category":"page"},{"location":"mutation/mutation1/","page":"Mutation","title":"Mutation","text":"mutation!.(E.ξ);","category":"page"},{"location":"mutation/mutation1/#Molecular-Dynamics-Exmaple","page":"Mutation","title":"Molecular Dynamics Exmaple","text":"","category":"section"},{"location":"mutation/mutation1/","page":"Mutation","title":"Mutation","text":"The following example formats one time step of the Euler-Maruyama molecular dynamics (MD) integrator in a way that it can be used with WeightedEnsemble. This employs the BasicMD package.  Here, we discretize the SDE,","category":"page"},{"location":"mutation/mutation1/","page":"Mutation","title":"Mutation","text":"dX_t = -nabla V(X_t)dt + sqrt2beta^-1dW_t","category":"page"},{"location":"mutation/mutation1/","page":"Mutation","title":"Mutation","text":"with time step Δt, and then take n steps of it to correspond to one step of the Markov chain:","category":"page"},{"location":"mutation/mutation1/","page":"Mutation","title":"Mutation","text":"sampler = EM(gradV!, β, Δt);\nopts = MDOptions(n_iters = n);\nmutation! = x -> sample_trajectory!(x, sampler, options = opts);","category":"page"},{"location":"mutation/mutation1/","page":"Mutation","title":"Mutation","text":"In a slight abuse of notation, the Markov chain, (X_k) that is used within WE corresponds to the skeleton of the continuous in time process, (X_k n Delta t ).","category":"page"},{"location":"#WeightedEnsemble.jl","page":"Home","title":"WeightedEnsemble.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 2","category":"page"},{"location":"#Algorithm-Overview","page":"Home","title":"Algorithm Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 3:4","category":"page"},{"location":"","page":"Home","title":"Home","text":"Weighted Ensemble (WE) is a variance reduction strategy that can be used to, amongst other things, estimate rare events.  More generally, it is designed to estimate","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbbE_muf(X) = mu(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"for some Quantity of Interest (QoI), f, with respect to some target measure, mu.   One of the major advantages of WE  over other variance reduction strategies is that it makes rather minimal assumptions on the Markov underlying process.  Indeed, there is no assumption of reversibility of the process, nor is there any need to evaluate or otherwise estimate a likelihood.  It is sufficient to be able to simulate the associated process, i.e., sample a Markov kernel, K, for which mu is the stationary distribution.  A key application of this approach is in the computation of mean first passage times (MFPTs) via the Hill relation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This implementation of WE makes use of a fixed number, N, particles, xi^i, each carrying weight omega^i.  At algorithmic time t, we denote","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu_t^N(dx) = sum_i=1^N omega_t^idelta_xi_t^i(dx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The weights are assumed to be positive and sum to one.  The particle ensemble is stored in an Ensemble data structure. The ensemble is evolved, successively, in two steps, selection and mutation.  As the partilces and weights evolve in time, we add a t subscript to indicate that these quantities change, (omega_t^ixi_t^i.","category":"page"},{"location":"#Selection","page":"Home","title":"Selection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"During the selection step, particles are resampled from the empirical distribution in such a way so as to maintain unbiasedness and reduce variance with respect to some quantity of interest.  The ensemble after selection is represented by","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatmu_t^N(dx) = sum_i=1^N hatomega_t^idelta_hatxi_t^i(dx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Selection Algorithms and related documents for additional details on this step.","category":"page"},{"location":"#Bins","page":"Home","title":"Bins","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To understand more of how the selection step works, it is essential to introduce the concept of bins.  Indeed, this implementation of WE is bin based, in the following sense.  The indices of the particles are partitioned into bins, u_1 u_2ldots u_M, where M is the number of partitions.  Often, these bins are determined by a disjoint partition of the state space, mathcalX as","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalX = bigcup_i=1^M mathcalB_i quad j in u_i leftrightarrow xi_t^jin mathcalB_i","category":"page"},{"location":"","page":"Home","title":"Home","text":"Though the presentation here assumes that the bins are statically (independent of t), these need not be the case in general.  Associated with each bin is the particle count at time t, n_t^i=u_i, and the bin weight, nu_t^i, given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"nu^i_t = sum_jin u_iomega^j","category":"page"},{"location":"","page":"Home","title":"Home","text":"The bins and their features are recorded in a Bins data structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To perform the selection step, one first performs the allocation steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, we determine how many particles should reside in each of the bins, C_t(u), after selection.  This is implemented to satisfy total particle conservation","category":"page"},{"location":"","page":"Home","title":"Home","text":"sum_i=1^MC_t(u_i) = N","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple, though suboptimal, choice is uniform allocation, in which C_t(u_i)approx 1M.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Second, we determine how many offspring each particle should have.  This is implemented to constrain the bin count from the first step,","category":"page"},{"location":"","page":"Home","title":"Home","text":"C_t(u_i)=sum_jin u_iC_t^j","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is typically done using multinomial resampling, with","category":"page"},{"location":"","page":"Home","title":"Home","text":"(C_t^j_k) sim mathrmMultileft(C_t(u_i)fracomega_t^j_1nu_t^ifracomega_t^j_2nu_t^ildots right)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the j_k in u_i.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Having allocated the number of offspring to each particle, we then repopulate our ensemble as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Offspring of particle xi_t^j are assigned this as their position;\nOffspring of particles in bin u_i are all assigned weight nu_t^iC_t(u_i).","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are some additional subtlesties that are implemented to ensure the allocation and selection with bins behaves as expected.","category":"page"},{"location":"#Mutation","page":"Home","title":"Mutation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"During the mutation step, the particles evolve freely over one algorithmic time unit according to a user defined Markov kernel, K, with xi_t+1^isim K(hatxi_t^i dx), and omega_t+1^i= hatomega_t^i.  We then have the updated ensemble,","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu_t+1^N(dx) = sum_i=1^N omega_t+1^idelta_xi_t+1^i(dx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Mutation for additional information on implemenation.","category":"page"},{"location":"#Unbiasedness","page":"Home","title":"Unbiasedness","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Repeating the above alternating selection/mutation steps, the key feature of WE is as follows. Denote by mu the invariant measure associated with the Markov kernel K such that mu K=mu.  Additionally, suppose omega_0^i=1N and xi_0^isim mu_0 be i.i.d.  Lastly, denote by mu_t = mu_0 K^t.  Then for any observable f,","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu_t(f)=mathbbE_mu_0f(X_t) = mathbbEmu_t^N(f)= mathbbEhatmu_t^N(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the latter two expectations are ensemble averages over the WE process.  Consequently, WE is unbiased, and it is providing N-particle approximations of the distribution, mu_t.","category":"page"},{"location":"#Estimation","page":"Home","title":"Estimation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WE can thus be used to compute averages against the associated a target stationary measure, mu, in the usual way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu(f) = lim_ttoinfty mu_t(f)= lim_tto inftyfrac1tsum_s=0^t-1 mu_s(f) = lim_tto inftyfrac1tsum_s=0^t-1 mu^N_s(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is what we will use to make estimates; by taking t sufficiently large,","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu(f) approx frac1tsum_s=0^t-1 mu^N_s(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A key thing to note is that WE does not accelerate mixing.  The mixing rate is controlled by the underlying Markov process.  What WE does do is, ideally, provide very low variance estimates of mu_t(f).  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"WE can also be used to estimate finite time non-equilibrium quantities.","category":"page"},{"location":"#Implementation","page":"Home","title":"Implementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To run WE, we must define a WEsampler sampler, which defines the above steps.  Indeed, to recap, one must code up steps for","category":"page"},{"location":"","page":"Home","title":"Home","text":"selection!(E, B, t) - This is an in place transform that modifies the ensemble, E, and the bins B.  It may be time dependent.\nmutation!(ξ) - This is an in place transform corresponds to the application of the Markov kernel to the state, xi sim K(xibullet).  Though this operation is vectorized, it does defined on the underlying state space, not the ensemble or bin structures.  It is assumed to be time homogeneous.\nsampler.rebin!(E, B, t+1) - This is applied after mutation, at time t+1, and determines which particles are in which bins, updating the structures accordingly.  It also retabulates the weight, nu_t^i of each bin.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Having defined a sampler structure and provided initial E0 ensemble and B0 bins structures, WE is then executed with the command","category":"page"},{"location":"","page":"Home","title":"Home","text":"n_we_steps = 10; \nE_trajectory, B_trajectory = run_we(E0, B0, sampler, n_we_steps);","category":"page"},{"location":"","page":"Home","title":"Home","text":"The data structures contain, amongst other things,:","category":"page"},{"location":"","page":"Home","title":"Home","text":"E_trajctory - (omega_t^i xi_t^i, (hatomega_t^i hatxi_t^i;\nB_trajectory - n_t^i, nu_t^i.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These can be used to compute the QoI.","category":"page"},{"location":"#Caveats","page":"Home","title":"Caveats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is some partial parallelization implemented, both with threads and with Distributed.  In both cases, the parallelization is only with respect to the application of the mutation! step, presumed to be the most costly piece of the algorithm.  It does not currently make use of distributed data structures or parallelize the selection step.","category":"page"},{"location":"#Collaborators","page":"Home","title":"Collaborators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"D. Aristoff\nJ. Copperman\nL. F. Doherty\nF. G. Jones\nR. J. Webber\nD. M. Zuckerman","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was supported in part by the US National Science Foundation Grants DMS-1818716 and DMS-2111278.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Aristoff, D., Copperman, J., Simpson, G., Webber, R. J. & Zuckerman, D. M. Weighted ensemble: Recent mathematical developments. J. Chem. Phys. 158, 014108 (2023).\nRusso, J. D. et al. WESTPA 2.0: High-Performance Upgrades for Weighted Ensemble Simulations and Analysis of Longer-Timescale Applications. J. Chem. Theory Comput. 18, 638–649 (2022).\nAristoff, D. An ergodic theorem for the weighted ensemble method. arXiv:1906.00856 (2021).\nWebber, R. J., Aristoff, D., & Simpson, G. A splitting method to reduce MCMC variance. arXiv:2011.13899 (2020)\nAristoff, D. & Zuckerman, D. M. Optimizing Weighted Ensemble Sampling of Steady States. Multiscale Model. Simul. 18, 646–673 (2020).\nHuber, G. A. & Kim, S. Weighted-ensemble Brownian dynamics simulations for protein association reactions. Biophysical Journal 70, 97–110 (1996).\nDouc, R. & Cappe, O. Comparison of resampling schemes for particle filtering. in ISPA 2005. Proceedings of the 4th International Symposium on Image and Signal Processing and Analysis, 2005. 64–69 (IEEE, Zagreb, Croatia, 2005). doi:10.1109/ISPA.2005.195385.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"selection/allocation1/#Allocation-Algorithms","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"","category":"section"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"Pages = [\"allocation1.md\"]","category":"page"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"The allocation methods determine:","category":"page"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"How many particles we should attempt to have within each bin.  \nHow many offspring each particle should have. ","category":"page"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"In the methods included here, one first allocates the number of particles to each bin, and then uses multinomial resampling, within each bin, to determine how many offspring each particle should have.  ","category":"page"},{"location":"selection/allocation1/#Bin-Allocation-Methods","page":"Allocation Algorithms","title":"Bin Allocation Methods","text":"","category":"section"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"    minimal_bin_allocation!","category":"page"},{"location":"selection/allocation1/#WeightedEnsemble.minimal_bin_allocation!","page":"Allocation Algorithms","title":"WeightedEnsemble.minimal_bin_allocation!","text":"minimal_bin_allocation!(B; νmin=νmin)\n\nAllocates a single particle to be spawned within each nonempty bin and the current number of particles in any bin with less than νmin total mass.\n\nArguments\n\nB - bin data structure\n\nOptional Arguments\n\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"    uniform_bin_allocation!","category":"page"},{"location":"selection/allocation1/#WeightedEnsemble.uniform_bin_allocation!","page":"Allocation Algorithms","title":"WeightedEnsemble.uniform_bin_allocation!","text":"uniform_bin_allocation!(B, E, n_allocate; allocation_resampler=systematic, νmin=νmin)\n\nUniformly allocate particles amongst bins.\n\nArguments\n\nB - bin data structure\nE - particle ensemble\nn_allocate - number of particles to allocate\n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"    optimal_bin_allocation!","category":"page"},{"location":"selection/allocation1/#WeightedEnsemble.optimal_bin_allocation!","page":"Allocation Algorithms","title":"WeightedEnsemble.optimal_bin_allocation!","text":"optimal_bin_allocation!(B, E, v², t, n_allocate; allocation_resampler=systematic, νmin=νmin)\n\nOptimally particles according to the bins, using a value function, v² to approximate mutation variance.\n\nArguments\n\nB - bin data structure\nE - particle ensemble\nv² - v² variance function estimator\nt - t-th seletion step\nn_allocate - number of particles to allocate \n\nOptional Arguments\n\nallocation_resampler=systematic - resampling scheme amongst bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"This function is defined in the spirit of the optimal allocation analysis of Aristoff & Zuckerman (2020).","category":"page"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"    targeted_bin_allocation!","category":"page"},{"location":"selection/allocation1/#WeightedEnsemble.targeted_bin_allocation!","page":"Allocation Algorithms","title":"WeightedEnsemble.targeted_bin_allocation!","text":"targeted_bin_allocation!(B::TB, E::TE, G::F, t::Int, n_allocate::Int; allocation_resampler=systematic, νmin=νmin) where {TE<:Ensemble,TB<:Bins,F<:Function}\n\nTargeted allocation of particles amongst bins using a specified function, G:(p, E, B, t) → [0,∞) for bin p.\n\nArguments\n\nB - bin data structure\nE - particle ensemble\nG - target function\nt - t-th seletion step\nn_allocate - number of particles to allocate\nOptional Arguments\nallocation_resampler=systematic - resampling scheme amongst bins\nνmin=νmin - minimal bin weight to avoid underflow\n\n\n\n\n\n","category":"function"},{"location":"selection/allocation1/#Particle-Allocation-Methods","page":"Allocation Algorithms","title":"Particle Allocation Methods","text":"","category":"section"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"    within_bin_allocation!","category":"page"},{"location":"selection/allocation1/#WeightedEnsemble.within_bin_allocation!","page":"Allocation Algorithms","title":"WeightedEnsemble.within_bin_allocation!","text":"within_bin_allocation!(E, B; within_bin_resampler=multinomial)\n\nOnce the number of offspring within each bin are set, allocate them amongst the particles within the bin.  This assumes that the bin allocations of the bins have completed.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\n\nOptional Arguments\n\nwithin_bin_resampler=multinomial - resampling scheme within bins\n\n\n\n\n\n","category":"function"},{"location":"selection/allocation1/#Utility-Functions","page":"Allocation Algorithms","title":"Utility Functions","text":"","category":"section"},{"location":"selection/allocation1/","page":"Allocation Algorithms","title":"Allocation Algorithms","text":"    trivial_allocation!","category":"page"},{"location":"selection/allocation1/#WeightedEnsemble.trivial_allocation!","page":"Allocation Algorithms","title":"WeightedEnsemble.trivial_allocation!","text":"trivial_allocation!(E, B)\n\nTrivially allocate each particle to have one offspring.\n\nArguments\n\nE - particle ensemble\nB - bin data structure\n\n\n\n\n\n","category":"function"},{"location":"selection/resampling1/#Resampling-Algorithms","page":"Resampling Algorithms","title":"Resampling Algorithms","text":"","category":"section"},{"location":"selection/resampling1/","page":"Resampling Algorithms","title":"Resampling Algorithms","text":"As it is neccessary to perform resampling, both for determining how many offspring each bin should have, and, having determined that, resampling the particles within each bin, we have provided several choices here.  These methods, and their properties, can be found in Douc et al. (2005).  The provided selection! functions default to using WeightedEnsemble.systematic across bins and WeightedEnsemble.multinomial within bins.","category":"page"},{"location":"selection/resampling1/","page":"Resampling Algorithms","title":"Resampling Algorithms","text":"All of these resampling methods take as their arguments, n, the number of trials, and ω, a vector of probabilities.  What is returned is a vector, Nvals, the same size as ω, containing the number allocated to each of the states.  These will satisfy the properties that sum(Nvals)=n, and the mean value of Nvals[i] (from repeated independent trials), is n * ω[i] for each i.","category":"page"},{"location":"selection/resampling1/","page":"Resampling Algorithms","title":"Resampling Algorithms","text":"WeightedEnsemble.residual\nWeightedEnsemble.stratified\nWeightedEnsemble.systematic\nWeightedEnsemble.multinomial","category":"page"},{"location":"selection/resampling1/#WeightedEnsemble.residual","page":"Resampling Algorithms","title":"WeightedEnsemble.residual","text":"residual(n,ω)\n\nPerform residual sampling\n\nArguments\n\nn - number of trials\nω - probabilities\n\n\n\n\n\n","category":"function"},{"location":"selection/resampling1/#WeightedEnsemble.stratified","page":"Resampling Algorithms","title":"WeightedEnsemble.stratified","text":"stratified(n,ω)\n\nPerform stratified sampling\n\nArguments\n\nn - number of trials\nω - probabilities\n\n\n\n\n\n","category":"function"},{"location":"selection/resampling1/#WeightedEnsemble.systematic","page":"Resampling Algorithms","title":"WeightedEnsemble.systematic","text":"systematic(n,ω)\n\nPerform systematic sampling\n\nArguments\n\nn - number of trials\nω - probabilities\n\n\n\n\n\n","category":"function"},{"location":"selection/resampling1/#WeightedEnsemble.multinomial","page":"Resampling Algorithms","title":"WeightedEnsemble.multinomial","text":"multinomial(n, ω)\n\nPerform multinomial sampling\n\nArguments\n\nn - number of trials\nω - probabilities\n\n\n\n\n\n","category":"function"}]
}
